!function(n){var e={};function t(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return n[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=n,t.c=e,t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:i})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(i,r,function(e){return n[e]}.bind(null,r));return i},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="/webpack/",t(t.s=468)}({0:function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},174:function(n,e,t){"use strict";t(0)(t(175))},175:function(n,e){n.exports="spweb.analytics = (function(globals, $, cookie){\n  /**\n   * Manages Google Analytics\n   * @module spweb/analytics\n   * @requires Global\n   * @requires jQuery\n   */\n\n  /*\n   Google Analytics custom variable slots (50 slots available):\n   1 Cached (page)\n   2 User Type (session)\n   3 Product (session)\n   4 ??\n   5 Market (page)\n   6 utm_source (session)\n   7 utm_medium (session)\n   8 utm_campaign (session)\n   */\n\n  'use strict';\n\n  var exports = {},\n    _trackingId = null,\n    _enableGaEvents;\n\n  globals.dataLayer = globals.dataLayer || [];\n\n  _enableGaEvents = function() {\n    $('[data-ga-category]').bind('click', function() {\n      var that = $(this);\n      var category = that.data('ga-category') || '';\n      var action = that.data('ga-action') || '';\n      var label = that.data('ga-label') || '';\n\n      if (category && action) {\n        exports.sendEvent(\n          category,\n          action,\n          label\n        );\n      }\n    });\n\n    $.subscribe('login_username_success', function() {\n      globals.dataLayer.push({'event': 'login_username_success'});\n    });\n\n    $.subscribe('login_facebook_success', function() {\n      globals.dataLayer.push({'event': 'login_facebook_success'});\n    });\n\n    if (cookie.get('sp_fblt')) {\n      $.publish('login_facebook_success');\n      cookie.remove('sp_fblt');\n    }\n  };\n\n  exports.getTest = function(testId){\n    var rawCookie, unescapedCookie, decodedJson, value;\n    rawCookie = cookie.get('sp_ab');\n    if (!rawCookie) {\n      return \"\";\n    }\n    unescapedCookie = unescape(rawCookie);\n    try {\n      decodedJson = JSON.parse(unescapedCookie);\n    } catch (err) {\n      return \"\";\n    }\n    if (!decodedJson) {\n      return \"\";\n    }\n    value = decodedJson[testId];\n    if (!value) {\n      return \"\";\n    }\n    return value;\n  };\n\n  /**\n   * Module set up:\n   * Initialize global ga variable\n   * Bind handlers for tracking Google Event tagged elements;\n   */\n  exports.init = function(){\n    if (globals.hasOwnProperty('dataLayer')) {\n      _enableGaEvents();\n    }\n  };\n\n  /**\n   * @deprecated use the sendEvent method below for Universal Analytics support\n   * @param {String} category\n   * @param {String} action\n   * @param {String} [label]\n   */\n  exports.trackEvent = function(category, action, label) {\n    this.sendEvent(category, action, label);\n  };\n\n  /**\n   * Wrapper around spAnalytics.logEvent api; send event data to GA and internal backend\n   * @param {String} category\n   * @param {String} action\n   * @param {String} [label]\n   * @param {Object} [context] arbitrary event data to be tracked\n   */\n  exports.sendEvent = function(category, action, label, context) {\n    if (typeof category !== 'string' || typeof action !== 'string') {\n      return;\n    }\n\n\n    // double tracking to compare old ga event logging against new backend architecture (via spAnalytics) \n    // that should be logging the same things. @jasonsmith to remove\n    globals.dataLayer.push({\n      'event': 'GAEvent',\n      'eventCategory': category,\n      'eventAction': action,\n      'eventLabel': label,\n      'eventValue': context\n    });\n    globals.spAnalytics.logEvent(category, action, label, context);\n  };\n\n  /**\n   * Send an event to GTM\n   * Optional eventType tells GTM how to handle the event\n   *\n   * @param {obj} opts\n   * @param {string} eventType use to instruct GTM what kind of event this is (GAEvent by default)\n   * @param {Object} [context] arbitrary event data to be tracked\n   */\n  exports.sendGtmEvent = function(opts, eventType) {\n\n    if (typeof opts.category !== 'string' || typeof opts.action !== 'string') {\n      return;\n    }\n\n    globals.dataLayer.push({\n      'event' :  eventType || 'GAEvent',\n      'eventCategory' : opts.category,\n      'eventAction' : opts.action,\n      'eventLabel' : opts.label,\n      'eventValue' : opts.value,\n      'eventCallback': opts.callback,\n      'ecommerce' : opts.ecommerce\n    });\n  };\n\n\n  return exports;\n\n}(typeof global !== 'undefined' ? global : window, jQuery, spweb.cookie));\n"},213:function(n,e,t){t(0)(t(214))},214:function(n,e){n.exports="\nif (typeof jQuery === 'undefined') {\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery')\n}\n\n+function ($) {\n  'use strict';\n  var version = $.fn.jquery.split(' ')[0].split('.')\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {\n    throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')\n  }\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: transition.js v3.3.7\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap')\n\n    var transEndEventNames = {\n      WebkitTransition : 'webkitTransitionEnd',\n      MozTransition    : 'transitionend',\n      OTransition      : 'oTransitionEnd otransitionend',\n      transition       : 'transitionend'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one('bsTransitionEnd', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: alert.js v3.3.7\n * http://getbootstrap.com/javascript/#alerts\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // ALERT CLASS DEFINITION\n  // ======================\n\n  var dismiss = '[data-dismiss=\"alert\"]'\n  var Alert   = function (el) {\n    $(el).on('click', dismiss, this.close)\n  }\n\n  Alert.VERSION = '3.3.7'\n\n  Alert.TRANSITION_DURATION = 150\n\n  Alert.prototype.close = function (e) {\n    var $this    = $(this)\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = $(selector === '#' ? [] : selector)\n\n    if (e) e.preventDefault()\n\n    if (!$parent.length) {\n      $parent = $this.closest('.alert')\n    }\n\n    $parent.trigger(e = $.Event('close.bs.alert'))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent.removeClass('in')\n\n    function removeElement() {\n      // detach from parent, fire event then clean up data\n      $parent.detach().trigger('closed.bs.alert').remove()\n    }\n\n    $.support.transition && $parent.hasClass('fade') ?\n      $parent\n        .one('bsTransitionEnd', removeElement)\n        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\n      removeElement()\n  }\n\n\n  // ALERT PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.alert')\n\n      if (!data) $this.data('bs.alert', (data = new Alert(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.alert\n\n  $.fn.alert             = Plugin\n  $.fn.alert.Constructor = Alert\n\n\n  // ALERT NO CONFLICT\n  // =================\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old\n    return this\n  }\n\n\n  // ALERT DATA-API\n  // ==============\n\n  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: button.js v3.3.7\n * http://getbootstrap.com/javascript/#buttons\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // BUTTON PUBLIC CLASS DEFINITION\n  // ==============================\n\n  var Button = function (element, options) {\n    this.$element  = $(element)\n    this.options   = $.extend({}, Button.DEFAULTS, options)\n    this.isLoading = false\n  }\n\n  Button.VERSION  = '3.3.7'\n\n  Button.DEFAULTS = {\n    loadingText: 'loading...'\n  }\n\n  Button.prototype.setState = function (state) {\n    var d    = 'disabled'\n    var $el  = this.$element\n    var val  = $el.is('input') ? 'val' : 'html'\n    var data = $el.data()\n\n    state += 'Text'\n\n    if (data.resetText == null) $el.data('resetText', $el[val]())\n\n    // push to event loop to allow forms to submit\n    setTimeout($.proxy(function () {\n      $el[val](data[state] == null ? this.options[state] : data[state])\n\n      if (state == 'loadingText') {\n        this.isLoading = true\n        $el.addClass(d).attr(d, d).prop(d, true)\n      } else if (this.isLoading) {\n        this.isLoading = false\n        $el.removeClass(d).removeAttr(d).prop(d, false)\n      }\n    }, this), 0)\n  }\n\n  Button.prototype.toggle = function () {\n    var changed = true\n    var $parent = this.$element.closest('[data-toggle=\"buttons\"]')\n\n    if ($parent.length) {\n      var $input = this.$element.find('input')\n      if ($input.prop('type') == 'radio') {\n        if ($input.prop('checked')) changed = false\n        $parent.find('.active').removeClass('active')\n        this.$element.addClass('active')\n      } else if ($input.prop('type') == 'checkbox') {\n        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false\n        this.$element.toggleClass('active')\n      }\n      $input.prop('checked', this.$element.hasClass('active'))\n      if (changed) $input.trigger('change')\n    } else {\n      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))\n      this.$element.toggleClass('active')\n    }\n  }\n\n\n  // BUTTON PLUGIN DEFINITION\n  // ========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.button')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.button', (data = new Button(this, options)))\n\n      if (option == 'toggle') data.toggle()\n      else if (option) data.setState(option)\n    })\n  }\n\n  var old = $.fn.button\n\n  $.fn.button             = Plugin\n  $.fn.button.Constructor = Button\n\n\n  // BUTTON NO CONFLICT\n  // ==================\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old\n    return this\n  }\n\n\n  // BUTTON DATA-API\n  // ===============\n\n  $(document)\n    .on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      var $btn = $(e.target).closest('.btn')\n      Plugin.call($btn, 'toggle')\n      if (!($(e.target).is('input[type=\"radio\"], input[type=\"checkbox\"]'))) {\n        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes\n        e.preventDefault()\n        // The target component still receive the focus\n        if ($btn.is('input,button')) $btn.trigger('focus')\n        else $btn.find('input:visible,button:visible').first().trigger('focus')\n      }\n    })\n    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))\n    })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: carousel.js v3.3.7\n * http://getbootstrap.com/javascript/#carousel\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CAROUSEL CLASS DEFINITION\n  // =========================\n\n  var Carousel = function (element, options) {\n    this.$element    = $(element)\n    this.$indicators = this.$element.find('.carousel-indicators')\n    this.options     = options\n    this.paused      = null\n    this.sliding     = null\n    this.interval    = null\n    this.$active     = null\n    this.$items      = null\n\n    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))\n\n    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element\n      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))\n      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))\n  }\n\n  Carousel.VERSION  = '3.3.7'\n\n  Carousel.TRANSITION_DURATION = 600\n\n  Carousel.DEFAULTS = {\n    interval: 5000,\n    pause: 'hover',\n    wrap: true,\n    keyboard: true\n  }\n\n  Carousel.prototype.keydown = function (e) {\n    if (/input|textarea/i.test(e.target.tagName)) return\n    switch (e.which) {\n      case 37: this.prev(); break\n      case 39: this.next(); break\n      default: return\n    }\n\n    e.preventDefault()\n  }\n\n  Carousel.prototype.cycle = function (e) {\n    e || (this.paused = false)\n\n    this.interval && clearInterval(this.interval)\n\n    this.options.interval\n      && !this.paused\n      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\n\n    return this\n  }\n\n  Carousel.prototype.getItemIndex = function (item) {\n    this.$items = item.parent().children('.item')\n    return this.$items.index(item || this.$active)\n  }\n\n  Carousel.prototype.getItemForDirection = function (direction, active) {\n    var activeIndex = this.getItemIndex(active)\n    var willWrap = (direction == 'prev' && activeIndex === 0)\n                || (direction == 'next' && activeIndex == (this.$items.length - 1))\n    if (willWrap && !this.options.wrap) return active\n    var delta = direction == 'prev' ? -1 : 1\n    var itemIndex = (activeIndex + delta) % this.$items.length\n    return this.$items.eq(itemIndex)\n  }\n\n  Carousel.prototype.to = function (pos) {\n    var that        = this\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))\n\n    if (pos > (this.$items.length - 1) || pos < 0) return\n\n    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, \"slid\"\n    if (activeIndex == pos) return this.pause().cycle()\n\n    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))\n  }\n\n  Carousel.prototype.pause = function (e) {\n    e || (this.paused = true)\n\n    if (this.$element.find('.next, .prev').length && $.support.transition) {\n      this.$element.trigger($.support.transition.end)\n      this.cycle(true)\n    }\n\n    this.interval = clearInterval(this.interval)\n\n    return this\n  }\n\n  Carousel.prototype.next = function () {\n    if (this.sliding) return\n    return this.slide('next')\n  }\n\n  Carousel.prototype.prev = function () {\n    if (this.sliding) return\n    return this.slide('prev')\n  }\n\n  Carousel.prototype.slide = function (type, next) {\n    var $active   = this.$element.find('.item.active')\n    var $next     = next || this.getItemForDirection(type, $active)\n    var isCycling = this.interval\n    var direction = type == 'next' ? 'left' : 'right'\n    var that      = this\n\n    if ($next.hasClass('active')) return (this.sliding = false)\n\n    var relatedTarget = $next[0]\n    var slideEvent = $.Event('slide.bs.carousel', {\n      relatedTarget: relatedTarget,\n      direction: direction\n    })\n    this.$element.trigger(slideEvent)\n    if (slideEvent.isDefaultPrevented()) return\n\n    this.sliding = true\n\n    isCycling && this.pause()\n\n    if (this.$indicators.length) {\n      this.$indicators.find('.active').removeClass('active')\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\n      $nextIndicator && $nextIndicator.addClass('active')\n    }\n\n    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, \"slid\"\n    if ($.support.transition && this.$element.hasClass('slide')) {\n      $next.addClass(type)\n      $next[0].offsetWidth // force reflow\n      $active.addClass(direction)\n      $next.addClass(direction)\n      $active\n        .one('bsTransitionEnd', function () {\n          $next.removeClass([type, direction].join(' ')).addClass('active')\n          $active.removeClass(['active', direction].join(' '))\n          that.sliding = false\n          setTimeout(function () {\n            that.$element.trigger(slidEvent)\n          }, 0)\n        })\n        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\n    } else {\n      $active.removeClass('active')\n      $next.addClass('active')\n      this.sliding = false\n      this.$element.trigger(slidEvent)\n    }\n\n    isCycling && this.cycle()\n\n    return this\n  }\n\n\n  // CAROUSEL PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.carousel')\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)\n      var action  = typeof option == 'string' ? option : options.slide\n\n      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))\n      if (typeof option == 'number') data.to(option)\n      else if (action) data[action]()\n      else if (options.interval) data.pause().cycle()\n    })\n  }\n\n  var old = $.fn.carousel\n\n  $.fn.carousel             = Plugin\n  $.fn.carousel.Constructor = Carousel\n\n\n  // CAROUSEL NO CONFLICT\n  // ====================\n\n  $.fn.carousel.noConflict = function () {\n    $.fn.carousel = old\n    return this\n  }\n\n\n  // CAROUSEL DATA-API\n  // =================\n\n  var clickHandler = function (e) {\n    var href\n    var $this   = $(this)\n    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')) // strip for ie7\n    if (!$target.hasClass('carousel')) return\n    var options = $.extend({}, $target.data(), $this.data())\n    var slideIndex = $this.attr('data-slide-to')\n    if (slideIndex) options.interval = false\n\n    Plugin.call($target, options)\n\n    if (slideIndex) {\n      $target.data('bs.carousel').to(slideIndex)\n    }\n\n    e.preventDefault()\n  }\n\n  $(document)\n    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)\n    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)\n\n  $(window).on('load', function () {\n    $('[data-ride=\"carousel\"]').each(function () {\n      var $carousel = $(this)\n      Plugin.call($carousel, $carousel.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: collapse.js v3.3.7\n * http://getbootstrap.com/javascript/#collapse\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n/* jshint latedef: false */\n\n+function ($) {\n  'use strict';\n\n  // COLLAPSE PUBLIC CLASS DEFINITION\n  // ================================\n\n  var Collapse = function (element, options) {\n    this.$element      = $(element)\n    this.options       = $.extend({}, Collapse.DEFAULTS, options)\n    this.$trigger      = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' +\n                           '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]')\n    this.transitioning = null\n\n    if (this.options.parent) {\n      this.$parent = this.getParent()\n    } else {\n      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\n    }\n\n    if (this.options.toggle) this.toggle()\n  }\n\n  Collapse.VERSION  = '3.3.7'\n\n  Collapse.TRANSITION_DURATION = 350\n\n  Collapse.DEFAULTS = {\n    toggle: true\n  }\n\n  Collapse.prototype.dimension = function () {\n    var hasWidth = this.$element.hasClass('width')\n    return hasWidth ? 'width' : 'height'\n  }\n\n  Collapse.prototype.show = function () {\n    if (this.transitioning || this.$element.hasClass('in')) return\n\n    var activesData\n    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')\n\n    if (actives && actives.length) {\n      activesData = actives.data('bs.collapse')\n      if (activesData && activesData.transitioning) return\n    }\n\n    var startEvent = $.Event('show.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    if (actives && actives.length) {\n      Plugin.call(actives, 'hide')\n      activesData || actives.data('bs.collapse', null)\n    }\n\n    var dimension = this.dimension()\n\n    this.$element\n      .removeClass('collapse')\n      .addClass('collapsing')[dimension](0)\n      .attr('aria-expanded', true)\n\n    this.$trigger\n      .removeClass('collapsed')\n      .attr('aria-expanded', true)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse in')[dimension]('')\n      this.transitioning = 0\n      this.$element\n        .trigger('shown.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    var scrollSize = $.camelCase(['scroll', dimension].join('-'))\n\n    this.$element\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\n  }\n\n  Collapse.prototype.hide = function () {\n    if (this.transitioning || !this.$element.hasClass('in')) return\n\n    var startEvent = $.Event('hide.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    var dimension = this.dimension()\n\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\n\n    this.$element\n      .addClass('collapsing')\n      .removeClass('collapse in')\n      .attr('aria-expanded', false)\n\n    this.$trigger\n      .addClass('collapsed')\n      .attr('aria-expanded', false)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.transitioning = 0\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse')\n        .trigger('hidden.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    this.$element\n      [dimension](0)\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\n  }\n\n  Collapse.prototype.toggle = function () {\n    this[this.$element.hasClass('in') ? 'hide' : 'show']()\n  }\n\n  Collapse.prototype.getParent = function () {\n    return $(this.options.parent)\n      .find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]')\n      .each($.proxy(function (i, element) {\n        var $element = $(element)\n        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\n      }, this))\n      .end()\n  }\n\n  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\n    var isOpen = $element.hasClass('in')\n\n    $element.attr('aria-expanded', isOpen)\n    $trigger\n      .toggleClass('collapsed', !isOpen)\n      .attr('aria-expanded', isOpen)\n  }\n\n  function getTargetFromTrigger($trigger) {\n    var href\n    var target = $trigger.attr('data-target')\n      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '') // strip for ie7\n\n    return $(target)\n  }\n\n\n  // COLLAPSE PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.collapse')\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\n      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.collapse\n\n  $.fn.collapse             = Plugin\n  $.fn.collapse.Constructor = Collapse\n\n\n  // COLLAPSE NO CONFLICT\n  // ====================\n\n  $.fn.collapse.noConflict = function () {\n    $.fn.collapse = old\n    return this\n  }\n\n\n  // COLLAPSE DATA-API\n  // =================\n\n  $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\n    var $this   = $(this)\n\n    if (!$this.attr('data-target')) e.preventDefault()\n\n    var $target = getTargetFromTrigger($this)\n    var data    = $target.data('bs.collapse')\n    var option  = data ? 'toggle' : $this.data()\n\n    Plugin.call($target, option)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.3.7\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.3.7'\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))\n    })\n  }\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $(document.createElement('div'))\n          .addClass('dropdown-backdrop')\n          .insertAfter($(this))\n          .on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger($.Event('shown.bs.dropdown', relatedTarget))\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if (!isActive && e.which != 27 || isActive && e.which == 27) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.disabled):visible a'\n    var $items = $parent.find('.dropdown-menu' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--         // up\n    if (e.which == 40 && index < $items.length - 1) index++         // down\n    if (!~index)                                    index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: modal.js v3.3.7\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  var Modal = function (element, options) {\n    this.options             = options\n    this.$body               = $(document.body)\n    this.$element            = $(element)\n    this.$dialog             = this.$element.find('.modal-dialog')\n    this.$backdrop           = null\n    this.isShown             = null\n    this.originalBodyPad     = null\n    this.scrollbarWidth      = 0\n    this.ignoreBackdropClick = false\n\n    if (this.options.remote) {\n      this.$element\n        .find('.modal-content')\n        .load(this.options.remote, $.proxy(function () {\n          this.$element.trigger('loaded.bs.modal')\n        }, this))\n    }\n  }\n\n  Modal.VERSION  = '3.3.7'\n\n  Modal.TRANSITION_DURATION = 300\n  Modal.BACKDROP_TRANSITION_DURATION = 150\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  }\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\n  }\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this\n    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })\n\n    this.$element.trigger(e)\n\n    if (this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = true\n\n    this.checkScrollbar()\n    this.setScrollbar()\n    this.$body.addClass('modal-open')\n\n    this.escape()\n    this.resize()\n\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this))\n\n    this.$dialog.on('mousedown.dismiss.bs.modal', function () {\n      that.$element.one('mouseup.dismiss.bs.modal', function (e) {\n        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\n      })\n    })\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass('fade')\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body) // don't move modals dom position\n      }\n\n      that.$element\n        .show()\n        .scrollTop(0)\n\n      that.adjustDialog()\n\n      if (transition) {\n        that.$element[0].offsetWidth // force reflow\n      }\n\n      that.$element.addClass('in')\n\n      that.enforceFocus()\n\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })\n\n      transition ?\n        that.$dialog // wait for modal to slide in\n          .one('bsTransitionEnd', function () {\n            that.$element.trigger('focus').trigger(e)\n          })\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n        that.$element.trigger('focus').trigger(e)\n    })\n  }\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault()\n\n    e = $.Event('hide.bs.modal')\n\n    this.$element.trigger(e)\n\n    if (!this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = false\n\n    this.escape()\n    this.resize()\n\n    $(document).off('focusin.bs.modal')\n\n    this.$element\n      .removeClass('in')\n      .off('click.dismiss.bs.modal')\n      .off('mouseup.dismiss.bs.modal')\n\n    this.$dialog.off('mousedown.dismiss.bs.modal')\n\n    $.support.transition && this.$element.hasClass('fade') ?\n      this.$element\n        .one('bsTransitionEnd', $.proxy(this.hideModal, this))\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n      this.hideModal()\n  }\n\n  Modal.prototype.enforceFocus = function () {\n    $(document)\n      .off('focusin.bs.modal') // guard against infinite focus loop\n      .on('focusin.bs.modal', $.proxy(function (e) {\n        if (document !== e.target &&\n            this.$element[0] !== e.target &&\n            !this.$element.has(e.target).length) {\n          this.$element.trigger('focus')\n        }\n      }, this))\n  }\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\n        e.which == 27 && this.hide()\n      }, this))\n    } else if (!this.isShown) {\n      this.$element.off('keydown.dismiss.bs.modal')\n    }\n  }\n\n  Modal.prototype.resize = function () {\n    if (this.isShown) {\n      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))\n    } else {\n      $(window).off('resize.bs.modal')\n    }\n  }\n\n  Modal.prototype.hideModal = function () {\n    var that = this\n    this.$element.hide()\n    this.backdrop(function () {\n      that.$body.removeClass('modal-open')\n      that.resetAdjustments()\n      that.resetScrollbar()\n      that.$element.trigger('hidden.bs.modal')\n    })\n  }\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this\n    var animate = this.$element.hasClass('fade') ? 'fade' : ''\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $(document.createElement('div'))\n        .addClass('modal-backdrop ' + animate)\n        .appendTo(this.$body)\n\n      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\n        if (this.ignoreBackdropClick) {\n          this.ignoreBackdropClick = false\n          return\n        }\n        if (e.target !== e.currentTarget) return\n        this.options.backdrop == 'static'\n          ? this.$element[0].focus()\n          : this.hide()\n      }, this))\n\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n      this.$backdrop.addClass('in')\n\n      if (!callback) return\n\n      doAnimate ?\n        this.$backdrop\n          .one('bsTransitionEnd', callback)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callback()\n\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass('in')\n\n      var callbackRemove = function () {\n        that.removeBackdrop()\n        callback && callback()\n      }\n      $.support.transition && this.$element.hasClass('fade') ?\n        this.$backdrop\n          .one('bsTransitionEnd', callbackRemove)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callbackRemove()\n\n    } else if (callback) {\n      callback()\n    }\n  }\n\n  // these following methods are used to handle overflowing modals\n\n  Modal.prototype.handleUpdate = function () {\n    this.adjustDialog()\n  }\n\n  Modal.prototype.adjustDialog = function () {\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\n\n    this.$element.css({\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\n    })\n  }\n\n  Modal.prototype.resetAdjustments = function () {\n    this.$element.css({\n      paddingLeft: '',\n      paddingRight: ''\n    })\n  }\n\n  Modal.prototype.checkScrollbar = function () {\n    var fullWindowWidth = window.innerWidth\n    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n      var documentElementRect = document.documentElement.getBoundingClientRect()\n      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\n    }\n    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth\n    this.scrollbarWidth = this.measureScrollbar()\n  }\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)\n    this.originalBodyPad = document.body.style.paddingRight || ''\n    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)\n  }\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css('padding-right', this.originalBodyPad)\n  }\n\n  Modal.prototype.measureScrollbar = function () { // thx walsh\n    var scrollDiv = document.createElement('div')\n    scrollDiv.className = 'modal-scrollbar-measure'\n    this.$body.append(scrollDiv)\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n    this.$body[0].removeChild(scrollDiv)\n    return scrollbarWidth\n  }\n\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.modal')\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))\n      if (typeof option == 'string') data[option](_relatedTarget)\n      else if (options.show) data.show(_relatedTarget)\n    })\n  }\n\n  var old = $.fn.modal\n\n  $.fn.modal             = Plugin\n  $.fn.modal.Constructor = Modal\n\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this   = $(this)\n    var href    = $this.attr('href')\n    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7\n    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\n\n    if ($this.is('a')) e.preventDefault()\n\n    $target.one('show.bs.modal', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\n      $target.one('hidden.bs.modal', function () {\n        $this.is(':visible') && $this.trigger('focus')\n      })\n    })\n    Plugin.call($target, option, this)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tooltip.js v3.3.7\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Tooltip = function (element, options) {\n    this.type       = null\n    this.options    = null\n    this.enabled    = null\n    this.timeout    = null\n    this.hoverState = null\n    this.$element   = null\n    this.inState    = null\n\n    this.init('tooltip', element, options)\n  }\n\n  Tooltip.VERSION  = '3.3.7'\n\n  Tooltip.TRANSITION_DURATION = 150\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: 'top',\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: 'body',\n      padding: 0\n    }\n  }\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled   = true\n    this.type      = type\n    this.$element  = $(element)\n    this.options   = this.getOptions(options)\n    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))\n    this.inState   = { click: false, hover: false, focus: false }\n\n    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\n      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')\n    }\n\n    var triggers = this.options.trigger.split(' ')\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i]\n\n      if (trigger == 'click') {\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))\n      } else if (trigger != 'manual') {\n        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'\n\n        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))\n      }\n    }\n\n    this.options.selector ?\n      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :\n      this.fixTitle()\n  }\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS\n  }\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\n\n    if (options.delay && typeof options.delay == 'number') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      }\n    }\n\n    return options\n  }\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options  = {}\n    var defaults = this.getDefaults()\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value\n    })\n\n    return options\n  }\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true\n    }\n\n    if (self.tip().hasClass('in') || self.hoverState == 'in') {\n      self.hoverState = 'in'\n      return\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'in'\n\n    if (!self.options.delay || !self.options.delay.show) return self.show()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'in') self.show()\n    }, self.options.delay.show)\n  }\n\n  Tooltip.prototype.isInStateTrue = function () {\n    for (var key in this.inState) {\n      if (this.inState[key]) return true\n    }\n\n    return false\n  }\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false\n    }\n\n    if (self.isInStateTrue()) return\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'out'\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'out') self.hide()\n    }, self.options.delay.hide)\n  }\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event('show.bs.' + this.type)\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e)\n\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n      if (e.isDefaultPrevented() || !inDom) return\n      var that = this\n\n      var $tip = this.tip()\n\n      var tipId = this.getUID(this.type)\n\n      this.setContent()\n      $tip.attr('id', tipId)\n      this.$element.attr('aria-describedby', tipId)\n\n      if (this.options.animation) $tip.addClass('fade')\n\n      var placement = typeof this.options.placement == 'function' ?\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\n        this.options.placement\n\n      var autoToken = /\\s?auto?\\s?/i\n      var autoPlace = autoToken.test(placement)\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\n\n      $tip\n        .detach()\n        .css({ top: 0, left: 0, display: 'block' })\n        .addClass(placement)\n        .data('bs.' + this.type, this)\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\n      this.$element.trigger('inserted.bs.' + this.type)\n\n      var pos          = this.getPosition()\n      var actualWidth  = $tip[0].offsetWidth\n      var actualHeight = $tip[0].offsetHeight\n\n      if (autoPlace) {\n        var orgPlacement = placement\n        var viewportDim = this.getPosition(this.$viewport)\n\n        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :\n                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :\n                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :\n                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :\n                    placement\n\n        $tip\n          .removeClass(orgPlacement)\n          .addClass(placement)\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\n\n      this.applyPlacement(calculatedOffset, placement)\n\n      var complete = function () {\n        var prevHoverState = that.hoverState\n        that.$element.trigger('shown.bs.' + that.type)\n        that.hoverState = null\n\n        if (prevHoverState == 'out') that.leave(that)\n      }\n\n      $.support.transition && this.$tip.hasClass('fade') ?\n        $tip\n          .one('bsTransitionEnd', complete)\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n        complete()\n    }\n  }\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip   = this.tip()\n    var width  = $tip[0].offsetWidth\n    var height = $tip[0].offsetHeight\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css('margin-top'), 10)\n    var marginLeft = parseInt($tip.css('margin-left'), 10)\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop))  marginTop  = 0\n    if (isNaN(marginLeft)) marginLeft = 0\n\n    offset.top  += marginTop\n    offset.left += marginLeft\n\n    // $.fn.offset doesn't round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function (props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        })\n      }\n    }, offset), 0)\n\n    $tip.addClass('in')\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth  = $tip[0].offsetWidth\n    var actualHeight = $tip[0].offsetHeight\n\n    if (placement == 'top' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\n\n    if (delta.left) offset.left += delta.left\n    else offset.top += delta.top\n\n    var isVertical          = /top|bottom/.test(placement)\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\n    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'\n\n    $tip.offset(offset)\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\n  }\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\n    this.arrow()\n      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n      .css(isVertical ? 'top' : 'left', '')\n  }\n\n  Tooltip.prototype.setContent = function () {\n    var $tip  = this.tip()\n    var title = this.getTitle()\n\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)\n    $tip.removeClass('fade in top bottom left right')\n  }\n\n  Tooltip.prototype.hide = function (callback) {\n    var that = this\n    var $tip = $(this.$tip)\n    var e    = $.Event('hide.bs.' + this.type)\n\n    function complete() {\n      if (that.hoverState != 'in') $tip.detach()\n      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.\n        that.$element\n          .removeAttr('aria-describedby')\n          .trigger('hidden.bs.' + that.type)\n      }\n      callback && callback()\n    }\n\n    this.$element.trigger(e)\n\n    if (e.isDefaultPrevented()) return\n\n    $tip.removeClass('in')\n\n    $.support.transition && $tip.hasClass('fade') ?\n      $tip\n        .one('bsTransitionEnd', complete)\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n      complete()\n\n    this.hoverState = null\n\n    return this\n  }\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element\n    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')\n    }\n  }\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle()\n  }\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element   = $element || this.$element\n\n    var el     = $element[0]\n    var isBody = el.tagName == 'BODY'\n\n    var elRect    = el.getBoundingClientRect()\n    if (elRect.width == null) {\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\n    }\n    var isSvg = window.SVGElement && el instanceof window.SVGElement\n    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.\n    // See https://github.com/twbs/bootstrap/issues/20280\n    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\n\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\n  }\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\n\n  }\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 }\n    if (!this.$viewport) return delta\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\n    var viewportDimensions = this.getPosition(this.$viewport)\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\n      }\n    } else {\n      var leftEdgeOffset  = pos.left - viewportPadding\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset\n      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\n      }\n    }\n\n    return delta\n  }\n\n  Tooltip.prototype.getTitle = function () {\n    var title\n    var $e = this.$element\n    var o  = this.options\n\n    title = $e.attr('data-original-title')\n      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)\n\n    return title\n  }\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do prefix += ~~(Math.random() * 1000000)\n    while (document.getElementById(prefix))\n    return prefix\n  }\n\n  Tooltip.prototype.tip = function () {\n    if (!this.$tip) {\n      this.$tip = $(this.options.template)\n      if (this.$tip.length != 1) {\n        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')\n      }\n    }\n    return this.$tip\n  }\n\n  Tooltip.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\n  }\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true\n  }\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false\n  }\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled\n  }\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this\n    if (e) {\n      self = $(e.currentTarget).data('bs.' + this.type)\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\n        $(e.currentTarget).data('bs.' + this.type, self)\n      }\n    }\n\n    if (e) {\n      self.inState.click = !self.inState.click\n      if (self.isInStateTrue()) self.enter(self)\n      else self.leave(self)\n    } else {\n      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)\n    }\n  }\n\n  Tooltip.prototype.destroy = function () {\n    var that = this\n    clearTimeout(this.timeout)\n    this.hide(function () {\n      that.$element.off('.' + that.type).removeData('bs.' + that.type)\n      if (that.$tip) {\n        that.$tip.detach()\n      }\n      that.$tip = null\n      that.$arrow = null\n      that.$viewport = null\n      that.$element = null\n    })\n  }\n\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.tooltip')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tooltip\n\n  $.fn.tooltip             = Plugin\n  $.fn.tooltip.Constructor = Tooltip\n\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: popover.js v3.3.7\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Popover = function (element, options) {\n    this.init('popover', element, options)\n  }\n\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')\n\n  Popover.VERSION  = '3.3.7'\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n  })\n\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\n\n  Popover.prototype.constructor = Popover\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS\n  }\n\n  Popover.prototype.setContent = function () {\n    var $tip    = this.tip()\n    var title   = this.getTitle()\n    var content = this.getContent()\n\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)\n    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events\n      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'\n    ](content)\n\n    $tip.removeClass('fade top bottom left right in')\n\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()\n  }\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent()\n  }\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element\n    var o  = this.options\n\n    return $e.attr('data-content')\n      || (typeof o.content == 'function' ?\n            o.content.call($e[0]) :\n            o.content)\n  }\n\n  Popover.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\n  }\n\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.popover')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.popover\n\n  $.fn.popover             = Plugin\n  $.fn.popover.Constructor = Popover\n\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: scrollspy.js v3.3.7\n * http://getbootstrap.com/javascript/#scrollspy\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // SCROLLSPY CLASS DEFINITION\n  // ==========================\n\n  function ScrollSpy(element, options) {\n    this.$body          = $(document.body)\n    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\n    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\n    this.selector       = (this.options.target || '') + ' .nav li > a'\n    this.offsets        = []\n    this.targets        = []\n    this.activeTarget   = null\n    this.scrollHeight   = 0\n\n    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))\n    this.refresh()\n    this.process()\n  }\n\n  ScrollSpy.VERSION  = '3.3.7'\n\n  ScrollSpy.DEFAULTS = {\n    offset: 10\n  }\n\n  ScrollSpy.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\n  }\n\n  ScrollSpy.prototype.refresh = function () {\n    var that          = this\n    var offsetMethod  = 'offset'\n    var offsetBase    = 0\n\n    this.offsets      = []\n    this.targets      = []\n    this.scrollHeight = this.getScrollHeight()\n\n    if (!$.isWindow(this.$scrollElement[0])) {\n      offsetMethod = 'position'\n      offsetBase   = this.$scrollElement.scrollTop()\n    }\n\n    this.$body\n      .find(this.selector)\n      .map(function () {\n        var $el   = $(this)\n        var href  = $el.data('target') || $el.attr('href')\n        var $href = /^#./.test(href) && $(href)\n\n        return ($href\n          && $href.length\n          && $href.is(':visible')\n          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\n      })\n      .sort(function (a, b) { return a[0] - b[0] })\n      .each(function () {\n        that.offsets.push(this[0])\n        that.targets.push(this[1])\n      })\n  }\n\n  ScrollSpy.prototype.process = function () {\n    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\n    var scrollHeight = this.getScrollHeight()\n    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\n    var offsets      = this.offsets\n    var targets      = this.targets\n    var activeTarget = this.activeTarget\n    var i\n\n    if (this.scrollHeight != scrollHeight) {\n      this.refresh()\n    }\n\n    if (scrollTop >= maxScroll) {\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\n    }\n\n    if (activeTarget && scrollTop < offsets[0]) {\n      this.activeTarget = null\n      return this.clear()\n    }\n\n    for (i = offsets.length; i--;) {\n      activeTarget != targets[i]\n        && scrollTop >= offsets[i]\n        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])\n        && this.activate(targets[i])\n    }\n  }\n\n  ScrollSpy.prototype.activate = function (target) {\n    this.activeTarget = target\n\n    this.clear()\n\n    var selector = this.selector +\n      '[data-target=\"' + target + '\"],' +\n      this.selector + '[href=\"' + target + '\"]'\n\n    var active = $(selector)\n      .parents('li')\n      .addClass('active')\n\n    if (active.parent('.dropdown-menu').length) {\n      active = active\n        .closest('li.dropdown')\n        .addClass('active')\n    }\n\n    active.trigger('activate.bs.scrollspy')\n  }\n\n  ScrollSpy.prototype.clear = function () {\n    $(this.selector)\n      .parentsUntil(this.options.target, '.active')\n      .removeClass('active')\n  }\n\n\n  // SCROLLSPY PLUGIN DEFINITION\n  // ===========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.scrollspy')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.scrollspy\n\n  $.fn.scrollspy             = Plugin\n  $.fn.scrollspy.Constructor = ScrollSpy\n\n\n  // SCROLLSPY NO CONFLICT\n  // =====================\n\n  $.fn.scrollspy.noConflict = function () {\n    $.fn.scrollspy = old\n    return this\n  }\n\n\n  // SCROLLSPY DATA-API\n  // ==================\n\n  $(window).on('load.bs.scrollspy.data-api', function () {\n    $('[data-spy=\"scroll\"]').each(function () {\n      var $spy = $(this)\n      Plugin.call($spy, $spy.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tab.js v3.3.7\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TAB CLASS DEFINITION\n  // ====================\n\n  var Tab = function (element) {\n    // jscs:disable requireDollarBeforejQueryAssignment\n    this.element = $(element)\n    // jscs:enable requireDollarBeforejQueryAssignment\n  }\n\n  Tab.VERSION = '3.3.7'\n\n  Tab.TRANSITION_DURATION = 150\n\n  Tab.prototype.show = function () {\n    var $this    = this.element\n    var $ul      = $this.closest('ul:not(.dropdown-menu)')\n    var selector = $this.data('target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    if ($this.parent('li').hasClass('active')) return\n\n    var $previous = $ul.find('.active:last a')\n    var hideEvent = $.Event('hide.bs.tab', {\n      relatedTarget: $this[0]\n    })\n    var showEvent = $.Event('show.bs.tab', {\n      relatedTarget: $previous[0]\n    })\n\n    $previous.trigger(hideEvent)\n    $this.trigger(showEvent)\n\n    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\n\n    var $target = $(selector)\n\n    this.activate($this.closest('li'), $ul)\n    this.activate($target, $target.parent(), function () {\n      $previous.trigger({\n        type: 'hidden.bs.tab',\n        relatedTarget: $this[0]\n      })\n      $this.trigger({\n        type: 'shown.bs.tab',\n        relatedTarget: $previous[0]\n      })\n    })\n  }\n\n  Tab.prototype.activate = function (element, container, callback) {\n    var $active    = container.find('> .active')\n    var transition = callback\n      && $.support.transition\n      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)\n\n    function next() {\n      $active\n        .removeClass('active')\n        .find('> .dropdown-menu > .active')\n          .removeClass('active')\n        .end()\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', false)\n\n      element\n        .addClass('active')\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', true)\n\n      if (transition) {\n        element[0].offsetWidth // reflow for transition\n        element.addClass('in')\n      } else {\n        element.removeClass('fade')\n      }\n\n      if (element.parent('.dropdown-menu').length) {\n        element\n          .closest('li.dropdown')\n            .addClass('active')\n          .end()\n          .find('[data-toggle=\"tab\"]')\n            .attr('aria-expanded', true)\n      }\n\n      callback && callback()\n    }\n\n    $active.length && transition ?\n      $active\n        .one('bsTransitionEnd', next)\n        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\n      next()\n\n    $active.removeClass('in')\n  }\n\n\n  // TAB PLUGIN DEFINITION\n  // =====================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.tab')\n\n      if (!data) $this.data('bs.tab', (data = new Tab(this)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tab\n\n  $.fn.tab             = Plugin\n  $.fn.tab.Constructor = Tab\n\n\n  // TAB NO CONFLICT\n  // ===============\n\n  $.fn.tab.noConflict = function () {\n    $.fn.tab = old\n    return this\n  }\n\n\n  // TAB DATA-API\n  // ============\n\n  var clickHandler = function (e) {\n    e.preventDefault()\n    Plugin.call($(this), 'show')\n  }\n\n  $(document)\n    .on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler)\n    .on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: affix.js v3.3.7\n * http://getbootstrap.com/javascript/#affix\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // AFFIX CLASS DEFINITION\n  // ======================\n\n  var Affix = function (element, options) {\n    this.options = $.extend({}, Affix.DEFAULTS, options)\n\n    this.$target = $(this.options.target)\n      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))\n      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))\n\n    this.$element     = $(element)\n    this.affixed      = null\n    this.unpin        = null\n    this.pinnedOffset = null\n\n    this.checkPosition()\n  }\n\n  Affix.VERSION  = '3.3.7'\n\n  Affix.RESET    = 'affix affix-top affix-bottom'\n\n  Affix.DEFAULTS = {\n    offset: 0,\n    target: window\n  }\n\n  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\n    var scrollTop    = this.$target.scrollTop()\n    var position     = this.$element.offset()\n    var targetHeight = this.$target.height()\n\n    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false\n\n    if (this.affixed == 'bottom') {\n      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'\n      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'\n    }\n\n    var initializing   = this.affixed == null\n    var colliderTop    = initializing ? scrollTop : position.top\n    var colliderHeight = initializing ? targetHeight : height\n\n    if (offsetTop != null && scrollTop <= offsetTop) return 'top'\n    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'\n\n    return false\n  }\n\n  Affix.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset\n    this.$element.removeClass(Affix.RESET).addClass('affix')\n    var scrollTop = this.$target.scrollTop()\n    var position  = this.$element.offset()\n    return (this.pinnedOffset = position.top - scrollTop)\n  }\n\n  Affix.prototype.checkPositionWithEventLoop = function () {\n    setTimeout($.proxy(this.checkPosition, this), 1)\n  }\n\n  Affix.prototype.checkPosition = function () {\n    if (!this.$element.is(':visible')) return\n\n    var height       = this.$element.height()\n    var offset       = this.options.offset\n    var offsetTop    = offset.top\n    var offsetBottom = offset.bottom\n    var scrollHeight = Math.max($(document).height(), $(document.body).height())\n\n    if (typeof offset != 'object')         offsetBottom = offsetTop = offset\n    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)\n    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)\n\n    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\n\n    if (this.affixed != affix) {\n      if (this.unpin != null) this.$element.css('top', '')\n\n      var affixType = 'affix' + (affix ? '-' + affix : '')\n      var e         = $.Event(affixType + '.bs.affix')\n\n      this.$element.trigger(e)\n\n      if (e.isDefaultPrevented()) return\n\n      this.affixed = affix\n      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null\n\n      this.$element\n        .removeClass(Affix.RESET)\n        .addClass(affixType)\n        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')\n    }\n\n    if (affix == 'bottom') {\n      this.$element.offset({\n        top: scrollHeight - height - offsetBottom\n      })\n    }\n  }\n\n\n  // AFFIX PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.affix')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.affix\n\n  $.fn.affix             = Plugin\n  $.fn.affix.Constructor = Affix\n\n\n  // AFFIX NO CONFLICT\n  // =================\n\n  $.fn.affix.noConflict = function () {\n    $.fn.affix = old\n    return this\n  }\n\n\n  // AFFIX DATA-API\n  // ==============\n\n  $(window).on('load', function () {\n    $('[data-spy=\"affix\"]').each(function () {\n      var $spy = $(this)\n      var data = $spy.data()\n\n      data.offset = data.offset || {}\n\n      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\n      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\n\n      Plugin.call($spy, data)\n    })\n  })\n\n}(jQuery);\n\n+function ($) {\n  'use strict';\n\n  // SIDEPANEL PUBLIC CLASS DEFINITION\n  // ==================================\n\n  var SidePanel = function(element, options) {\n    var isForcedHamburgerMode = $('html, body').hasClass('force-hamburger');\n\n    this.options = $.extend({}, SidePanel.DEFAULTS, options);\n    this.isVisible = false;\n\n    this.$element = $(element);\n    this.$navbarHeader = $(element).siblings('.navbar-header');\n    this.$container = this.$element.parents('.navbar');\n    this.$toggle = this.$navbarHeader.find('.navbar-toggle');\n\n    this.animationEndEvent = _whichAnimationEndEvent();\n\n    $(window).resize(function() {\n      if(this.isVisible && window.innerWidth >= SidePanel.TOGGLE_BREAKPOINT && !isForcedHamburgerMode) {\n        this.hide({\n          skipAnimation: true\n        });\n      } else if(this.isVisible) {\n        this.setDimensions();\n      }\n    }.bind(this));\n\n    this.setDimensions();\n\n    if(this.options.toggle) this.toggle();\n  }\n\n  SidePanel.TOGGLE_BREAKPOINT = 992; // px\n  SidePanel.MOBILE_BREAKPOINT = 480; // px\n  SidePanel.DESKTOP_WIDTH = 400; // px\n  SidePanel.MOBILE_WIDTH = 270; // px\n  SidePanel.SIDEPANEL_PADDING = 38; // px\n  SidePanel.CLOSE_DURATION = 270; // ms\n  SidePanel.MENU_ITEM_ANIMATION_DELAY = 17; // ms\n\n  SidePanel.DEFAULTS = {};\n\n  SidePanel.prototype.setDimensions = function() {\n    var navbarWidth = this._getNavBarWidth();\n    var navScrollHeight = this.$element.find('.nav')[0].scrollHeight;\n    // NOTE: expecting .navbar-brand to be wrapped in <li>\n    var navBranding = this.$element.find('.navbar-brand').parent();\n    \n    var toggleGutter; \n    if(this.$toggleClone) {\n      toggleGutter = window.innerWidth - this.$toggleClone.position().left;\n    } else {\n      toggleGutter = window.innerWidth - this.$toggle.position().left;\n    }\n\n    if(_isTouchDevice()) {\n      this.$element.css({'width': '100%'});\n\n      // force iOS to recalc the panel height to prevent a bug with scrolling on orientation change\n      this.$element.css('overflow', 'hidden').height();\n      this.$element.css('overflow', 'auto');\n    } else {\n      // put the brand at the bottom of the panel unless the panel is large, then just put in the verticle flow\n      if(navScrollHeight + navBranding.outerHeight(true) + SidePanel.SIDEPANEL_PADDING < window.innerHeight) {\n        navBranding.addClass('fixed-bottom');\n      } else {\n        navBranding.removeClass('fixed-bottom');\n      }\n      if(window.innerWidth >= SidePanel.MOBILE_BREAKPOINT) {\n        this.$element.css({width: (toggleGutter + SidePanel.DESKTOP_WIDTH) + 'px'});\n      } else {\n        this.$element.css({width: (toggleGutter + SidePanel.MOBILE_WIDTH) + 'px'});\n      } \n    } \n\n    if(this.$toggleClone) {\n      var curLeftPos = this.$toggle.position().left;\n      this.$toggleClone.css({\n        'left': curLeftPos + 'px', \n        'top': 0\n      });\n    }\n  }\n\n  SidePanel.prototype.toggle = function() {\n    this[this.isVisible ? 'hide' : 'show']();\n  }\n\n  SidePanel.prototype.show = function() {\n    if(this.isTransitioning) {\n      return;\n    }\n\n    this.isVisible = true;\n    this.$toggle.removeClass('collapsed');\n\n    $('body').addClass('sidepanel-active');\n    this.$container.addClass('navbar-sidepanel');\n\n    // if branding is not present, add it in\n    if(!this.$element.find('.navbar-brand').length) {\n      this._generateBrand();\n    }\n\n    // dynamically apply animation delay to create swinging effect\n    if(this.animationEndEvent) {\n      this.$element.find('li a, .divider').each(function(i,e) {\n        $(e).css({'animation-delay': i * SidePanel.MENU_ITEM_ANIMATION_DELAY + 'ms'})\n      });\n    }\n\n    // create a backdrop\n    this.$container.prepend('<div class=\"sidepanel-backdrop\"></div>');\n    this.$container.on('click.sp.sidepanel', '.sidepanel-backdrop', function() {\n      this.hide();\n    }.bind(this));\n    \n    if(this.animationEndEvent) {\n      this.$element.one(this.animationEndEvent, function() {\n        this.isTransitioning = false;\n        this.$element.removeClass('animate-in');\n        this.$element.addClass('open');\n      }.bind(this));\n\n      this.isTransitioning = true;\n      this.$element.addClass('animate-in');\n    } else {\n      this.$element.addClass('open');\n    }\n\n    this.setDimensions();\n\n    // if the entire header is not fixed we handle the toggle button differently\n    // we don't want the toggle button to appear in the middle of the sidepanel\n    // so we clone the current toggle and affix the clone to the top-right of the view\n    if(this.$container.css('position') !== 'fixed') {\n      var curLeftPos = this.$toggle.position().left;\n      this.$toggleClone = this.$toggle.clone();\n      this.$toggle.css({\n        'opacity': 0\n      });\n      this.$toggleClone.css({\n        'display': 'none',\n        'position': 'fixed', \n        'left': curLeftPos + 'px', \n        'top': 0\n      });\n      this.$toggle.after(this.$toggleClone);\n      this.$toggleClone.show();\n    }\n  }\n\n  SidePanel.prototype.hide = function(options) {\n    var options = options || {};\n\n    if(this.isTransitioning) {\n      return;\n    }\n\n    this.isVisible = false;\n    this.$toggle.addClass('collapsed');\n\n    if(this.$toggleClone) {\n      this.$toggleClone.remove();\n      this.$toggle.css({\n        'opacity': 1\n      });\n      delete this.$toggleClone;\n    }\n\n    if(this.animationEndEvent && !options.skipAnimation) {\n      this.$element.one(this.animationEndEvent, function() {\n        this.isTransitioning = false;\n        this.$element.removeClass('animate-out');\n        complete.call(this, null);\n      }.bind(this));\n\n      this.isTransitioning = true;\n      this.$container.find('.sidepanel-backdrop').fadeOut(SidePanel.CLOSE_DURATION);\n      this.$element.addClass('animate-out');\n    } else {\n      complete.call(this, null);\n    }\n    \n    function complete() {\n      // remove some elements we created\n      this.$container.find('._generated-nav-brand').remove();\n      this.$container.find('.sidepanel-backdrop').remove();\n\n      this.$element\n        .css({width: 'auto'})\n        .removeClass('open');\n\n      this.$container.removeClass('navbar-sidepanel');\n      $('body').removeClass('sidepanel-active');\n    }\n  }\n\n  SidePanel.prototype._getNavBarWidth = function() {\n    return this.$element.outerWidth(true);\n  }\n\n  SidePanel.prototype._generateBrand = function() {\n    var currentTitleBrand = this.$container.find('.navbar-brand').clone();\n    var brandListItem = $('<li class=\"_generated-nav-brand\">').append(currentTitleBrand);\n    this.$element.find('.nav').append(brandListItem);\n  }\n\n  function _whichAnimationEndEvent(){\n    /* similar to Modernizr */\n    var a;\n    var el = document.createElement('fakeelement');\n    var animationEndEvents = {\n      'animation':'animationend',\n      'OAnimation':'oAnimationEnd',\n      'MozAnimation':'animationend',\n      'WebkitAnimation':'webkitAnimationEnd'\n    }\n\n    for(a in animationEndEvents){\n      if(el.style[a] !== undefined){\n        return animationEndEvents[a];\n      }\n    }\n  }\n\n  function _isTouchDevice() {\n    return 'ontouchstart' in window // works on most browsers \n        || 'onmsgesturechange' in window; // works on ie10\n  };\n\n  // SIDEPANEL PLUGIN DEFINITION\n  // ============================\n\n  function Plugin(option) {\n    return this.each(function() {\n      var $this = $(this);\n      var data = $this.data('sp.sidepanel');\n      var options = $.extend({}, SidePanel.DEFAULTS, $this.data(), typeof option == 'object' && option);\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;\n      if (!data) $this.data('sp.sidepanel', (data = new SidePanel(this, options)));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.spSidepanel;\n\n  $.fn.spSidepanel = Plugin;\n  $.fn.spSidepanel.Constructor = SidePanel;\n\n  // SIDEPANEL NO CONFLICT\n  // ======================\n\n  $.fn.spSidepanel.noConflict = function () {\n    $.fn.spSidepanel = old;\n    return this;\n  }\n\n  // SIDEPANEL DATA-API\n  // ===================\n\n  $(document).off('click.sp.sidepanel').on('click.sp.sidepanel', '[data-toggle=sidepanel]', function(e) {\n    var $this = $(this);\n\n    if(!$this.attr('data-target')) {\n      e.preventDefault();\n    }\n\n    var $target = $($this.attr('data-target'));\n    var data = $target.data('sp.sidepanel');\n    var option = data ? 'toggle' : $this.data();\n\n    Plugin.call($target, option);\n  });\n\n}(jQuery);\n\n+function ($) {\n  'use strict';\n\n  // BUTTONSCROLL PUBLIC CLASS DEFINITION\n  // ==================================\n\n  var ButtonScroll = function(element, options) {\n    this.options = $.extend({}, ButtonScroll.DEFAULTS, options);\n    this.$element = $(element);\n\n    this.scroll();\n  }\n\n  // CONSTANTS AND DEFAULTS\n  // ============================\n\n  ButtonScroll.ANIMATION_DURATION = 500;\n  ButtonScroll.BODY = $('html, body');\n\n  ButtonScroll.DEFAULTS = {\n    'body': ButtonScroll.BODY,\n    'animationDuration': ButtonScroll.ANIMATION_DURATION\n  };\n\n  ButtonScroll.prototype.scroll = function() {\n    var target = $('[name=\"' + $.attr(this.$element[0], 'href').substr(1) + '\"]');\n    this.options.body.animate({\n      scrollTop: target.offset().top\n    }, this.options.animationDuration);\n  }\n\n  // BUTTONSCROLL PLUGIN DEFINITION\n  // ============================\n\n  function Plugin(option) {\n    return this.each(function() {\n      var $this = $(this);\n      var data = $this.data('sp.buttonscroll');\n      var options = $.extend({}, ButtonScroll.DEFAULTS, $this.data(), typeof option == 'object' && option);\n\n      if (!data) $this.data('sp.buttonscroll', (data = new ButtonScroll(this, options)));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var oldFn = $.fn.spButtonScroll;\n\n  $.fn.spButtonScroll = Plugin;\n  $.fn.spButtonScroll.Constructor = ButtonScroll;\n\n  // BUTTONSCROLL NO CONFLICT\n  // ======================\n\n  $.fn.spButtonScroll.noConflict = function () {\n    $.fn.spButtonScroll = oldFn;\n    return this;\n  }\n\n  // BUTTONSCROLL DATA-API\n  // ===================\n\n  $(document).off('click.sp.buttonscroll').on('click.sp.buttonscroll', 'a.btn-scroll', function(e) {\n    var $this = $(this);\n\n    e.preventDefault();\n    var data = $this.data('sp.buttonscroll');\n\n    var options = data ? 'scroll' : $this.data();\n    Plugin.call($this, options);\n  });\n\n}(jQuery);\n\n"},219:function(n,e,t){"use strict";t(0)(t(220))},220:function(n,e){n.exports='/*\n * jQuery Tiny Pub/Sub\n * https://github.com/cowboy/jquery-tiny-pubsub\n *\n * Copyright (c) 2013 "Cowboy" Ben Alman\n * Licensed under the MIT license.\n */\n\n(function($) {\n\n  var o = $({});\n\n  $.subscribe = function() {\n    o.on.apply(o, arguments);\n  };\n\n  $.unsubscribe = function() {\n    o.off.apply(o, arguments);\n  };\n\n  $.publish = function() {\n    o.trigger.apply(o, arguments);\n  };\n\n}(jQuery));\n'},221:function(n,e,t){"use strict";t(0)(t(222))},222:function(n,e){n.exports="/*eslint strict:0*/\n\n/*\n * Check if console is defined.\n * Avoid errors caused by debug-code.\n */\nif (typeof window.console === 'undefined') {\n  window.console = {\n    log: function() {}\n  };\n}\n\n\n/**\n * @namespace Defines the spotify.com global namespace.\n */\nvar spweb = spweb || {};\n"},223:function(n,e,t){"use strict";t(0)(t(224))},224:function(n,e){n.exports="spweb.cookie = (function() {\n  /**\n   * Cookie handling\n   * @module spweb/cookie\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * Set the value for a given cookie. Create cookie if it does not exist.\n   * @param {Object} params\n   * @param {String} params.name Name of the cookie\n   * @param {String} [params.value] Value to set. Delete the cookie if this is omitted.\n   * @param {Integer}[params.expires] Days cookie is valid for. Defaults to session cookie if omitted.\n   * @param {String} [params.domain] Value to set. Default to current domain if omitted\n   */\n  exports.set = function(params) {\n    var name = params.name,\n      value,\n      expires,\n      domain;\n\n    if (typeof params.value === 'undefined') {\n      value = '';\n      expires = '-1';\n    } else {\n      value = params.value;\n    }\n\n    if (typeof params.expires !== 'undefined') {\n      var date = new Date();\n      date.setTime(date.getTime() + (params.expires * 24 * 60 * 60 * 1000));\n      expires = '; expires=' + date.toGMTString();\n    } else {\n      expires = '';\n    }\n\n    if (typeof params.domain !== 'undefined' && params.domain !== null) {\n      domain = '; domain=' + params.domain;\n    } else {\n      domain = '';\n    }\n\n    window.document.cookie = name + '=' + value + expires + domain + '; path=/';\n  };\n\n  /**\n   * Retrieve a cookie's value\n   * @param {String} name\n   * @returns {String|null}\n   */\n  exports.get = function(name) {\n    var nameEQ = name + '=',\n      ca = window.document.cookie.split(';'),\n      i;\n\n    for(i = 0; i < ca.length; i += 1) {\n      var c = ca[i];\n\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1, c.length);\n      }\n      if (c.indexOf(nameEQ) === 0) {\n        return c.substring(nameEQ.length, c.length);\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Delete a cookie\n   * @param {String} name of cookie to delete\n   */\n  exports.remove = function(name) {\n    this.set({name: name});\n  };\n\n  return exports;\n}());\n"},225:function(n,e,t){"use strict";t(0)(t(226))},226:function(n,e){n.exports="spweb.modal = (function ($, utils) {\n  /**\n   * @deprecated - We will transition to bootstrap modal as soon as possible.\n   *\n   * This module is responsible for modal display -- this is strictly iframed youtube embeds right now.\n   * It adds a click handler to elements with the specified\n   * css hook. The handler will open the modal on click of the element.\n   *\n   * @module spweb/modal\n   * @requires jQuery\n   * @requires spweb.utils\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  exports.init = function () {\n\n    $(document).on('click.modal', '[data-open=\"modal\"]', function(e) {\n      var youtubeId = $(this).data('youtube-id'),\n        modalYouttube;\n\n      e.preventDefault();\n\n      modalYouttube = $(\n        '<div class=\"modal\">' +\n          '<div class=\"modal-dialog modal-lg\">' +\n            '<div class=\"modal-content\">' +\n              '<div class=\"embed-responsive embed-responsive-16by9\">' +\n                '<iframe class=\"embed-responsive-item\" src=\"//www.youtube.com/embed/' + youtubeId + '?modestbranding=1&rel=0&autoplay=1&controls=1\" frameborder=\"0\" allowfullscreen></iframe>' +\n              '</div>' +\n            '</div>' +\n          '</div>' +\n        '</div>'\n      );\n\n      $('body').append(modalYouttube);\n\n      // We publish the foreground_video_play event. Any background videos - e.g. the hero video\n      // can subscribe to this. It is indended that a background video will pause when a foreground\n      // video starts playing.\n      $.publish('foreground_video_play');\n\n      modalYouttube.click(function() {\n\n        // When we click the background to hide the modal video, we raise the foreground_video_stop\n        // event. Any background videos - e.g. the hero video can subscribe to this. It is indended\n        // that a background video will start playing when a foreground video stops playing.\n        $.publish('foreground_video_stop');\n\n        modalYouttube.remove();\n      });\n\n      // This is the bootstrap event that should fire when the modal is hidden. However, it doesn't\n      // fire when we click the modal background (above). This is because we short-cut the modal\n      // close behaviour by just removing it from the DOM. I don't know if there is another method\n      // of closing the modal (the escape key doesn't seem to work), but I've left this in in case\n      // there's a edge-case method I don't know about.\n      modalYouttube.on('hidden.bs.modal', function() {\n        $.publish('foreground_video_stop');\n      });\n\n    });\n\n    // If we have the autoplay=1 querystring parameter set, we select the first modal on the page,\n    // and automatically pop it up. I don't think there are currently any pages where we have more\n    // than one modal, so this will do for now. I the future this could be extended to allow the\n    // correct autoplay modal to be specified in the url.\n    if (utils.getQueryParameter('autoplay') === '1') {\n      var firstModal = $('[data-open=\"modal\"]').first();\n      if (firstModal.length > 0) {\n        firstModal.click();\n      }\n    }\n\n  };\n\n  return exports;\n\n}(jQuery, spweb.utils));\n"},290:function(n,e,t){t(0)(t(291))},291:function(n,e){n.exports=";(function () {\n\t'use strict';\n\n\t/**\n\t * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.\n\t *\n\t * @codingstandard ftlabs-jsv2\n\t * @copyright The Financial Times Limited [All Rights Reserved]\n\t * @license MIT License (see LICENSE.txt)\n\t */\n\n\t/*jslint browser:true, node:true*/\n\t/*global define, Event, Node*/\n\n\n\t/**\n\t * Instantiate fast-clicking listeners on the specified layer.\n\t *\n\t * @constructor\n\t * @param {Element} layer The layer to listen on\n\t * @param {Object} [options={}] The options to override the defaults\n\t */\n\tfunction FastClick(layer, options) {\n\t\tvar oldOnClick;\n\n\t\toptions = options || {};\n\n\t\t/**\n\t\t * Whether a click is currently being tracked.\n\t\t *\n\t\t * @type boolean\n\t\t */\n\t\tthis.trackingClick = false;\n\n\n\t\t/**\n\t\t * Timestamp for when click tracking started.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.trackingClickStart = 0;\n\n\n\t\t/**\n\t\t * The element being tracked for a click.\n\t\t *\n\t\t * @type EventTarget\n\t\t */\n\t\tthis.targetElement = null;\n\n\n\t\t/**\n\t\t * X-coordinate of touch start event.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.touchStartX = 0;\n\n\n\t\t/**\n\t\t * Y-coordinate of touch start event.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.touchStartY = 0;\n\n\n\t\t/**\n\t\t * ID of the last touch, retrieved from Touch.identifier.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.lastTouchIdentifier = 0;\n\n\n\t\t/**\n\t\t * Touchmove boundary, beyond which a click will be cancelled.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.touchBoundary = options.touchBoundary || 10;\n\n\n\t\t/**\n\t\t * The FastClick layer.\n\t\t *\n\t\t * @type Element\n\t\t */\n\t\tthis.layer = layer;\n\n\t\t/**\n\t\t * The minimum time between tap(touchstart and touchend) events\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.tapDelay = options.tapDelay || 200;\n\n\t\t/**\n\t\t * The maximum time for a tap\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.tapTimeout = options.tapTimeout || 700;\n\n\t\tif (FastClick.notNeeded(layer)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Some old versions of Android don't have Function.prototype.bind\n\t\tfunction bind(method, context) {\n\t\t\treturn function() { return method.apply(context, arguments); };\n\t\t}\n\n\n\t\tvar methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];\n\t\tvar context = this;\n\t\tfor (var i = 0, l = methods.length; i < l; i++) {\n\t\t\tcontext[methods[i]] = bind(context[methods[i]], context);\n\t\t}\n\n\t\t// Set up event handlers as required\n\t\tif (deviceIsAndroid) {\n\t\t\tlayer.addEventListener('mouseover', this.onMouse, true);\n\t\t\tlayer.addEventListener('mousedown', this.onMouse, true);\n\t\t\tlayer.addEventListener('mouseup', this.onMouse, true);\n\t\t}\n\n\t\tlayer.addEventListener('click', this.onClick, true);\n\t\tlayer.addEventListener('touchstart', this.onTouchStart, false);\n\t\tlayer.addEventListener('touchmove', this.onTouchMove, false);\n\t\tlayer.addEventListener('touchend', this.onTouchEnd, false);\n\t\tlayer.addEventListener('touchcancel', this.onTouchCancel, false);\n\n\t\t// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\n\t\t// layer when they are cancelled.\n\t\tif (!Event.prototype.stopImmediatePropagation) {\n\t\t\tlayer.removeEventListener = function(type, callback, capture) {\n\t\t\t\tvar rmv = Node.prototype.removeEventListener;\n\t\t\t\tif (type === 'click') {\n\t\t\t\t\trmv.call(layer, type, callback.hijacked || callback, capture);\n\t\t\t\t} else {\n\t\t\t\t\trmv.call(layer, type, callback, capture);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlayer.addEventListener = function(type, callback, capture) {\n\t\t\t\tvar adv = Node.prototype.addEventListener;\n\t\t\t\tif (type === 'click') {\n\t\t\t\t\tadv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {\n\t\t\t\t\t\tif (!event.propagationStopped) {\n\t\t\t\t\t\t\tcallback(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}), capture);\n\t\t\t\t} else {\n\t\t\t\t\tadv.call(layer, type, callback, capture);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// If a handler is already declared in the element's onclick attribute, it will be fired before\n\t\t// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\n\t\t// adding it as listener.\n\t\tif (typeof layer.onclick === 'function') {\n\n\t\t\t// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\n\t\t\t// - the old one won't work if passed to addEventListener directly.\n\t\t\toldOnClick = layer.onclick;\n\t\t\tlayer.addEventListener('click', function(event) {\n\t\t\t\toldOnClick(event);\n\t\t\t}, false);\n\t\t\tlayer.onclick = null;\n\t\t}\n\t}\n\n\t/**\n\t* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.\n\t*\n\t* @type boolean\n\t*/\n\tvar deviceIsWindowsPhone = navigator.userAgent.indexOf(\"Windows Phone\") >= 0;\n\n\t/**\n\t * Android requires exceptions.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;\n\n\n\t/**\n\t * iOS requires exceptions.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;\n\n\n\t/**\n\t * iOS 4 requires an exception for select elements.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsIOS4 = deviceIsIOS && (/OS 4_\\d(_\\d)?/).test(navigator.userAgent);\n\n\n\t/**\n\t * iOS 6.0-7.* requires the target element to be manually derived\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\\d/).test(navigator.userAgent);\n\n\t/**\n\t * BlackBerry requires exceptions.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;\n\n\t/**\n\t * Determine whether a given element requires a native click.\n\t *\n\t * @param {EventTarget|Element} target Target DOM element\n\t * @returns {boolean} Returns true if the element needs a native click\n\t */\n\tFastClick.prototype.needsClick = function(target) {\n\t\tswitch (target.nodeName.toLowerCase()) {\n\n\t\t// Don't send a synthetic click to disabled inputs (issue #62)\n\t\tcase 'button':\n\t\tcase 'select':\n\t\tcase 'textarea':\n\t\t\tif (target.disabled) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'input':\n\n\t\t\t// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)\n\t\t\tif ((deviceIsIOS && target.type === 'file') || target.disabled) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'label':\n\t\tcase 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames\n\t\tcase 'video':\n\t\t\treturn true;\n\t\t}\n\n\t\treturn (/\\bneedsclick\\b/).test(target.className);\n\t};\n\n\n\t/**\n\t * Determine whether a given element requires a call to focus to simulate click into element.\n\t *\n\t * @param {EventTarget|Element} target Target DOM element\n\t * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\n\t */\n\tFastClick.prototype.needsFocus = function(target) {\n\t\tswitch (target.nodeName.toLowerCase()) {\n\t\tcase 'textarea':\n\t\t\treturn true;\n\t\tcase 'select':\n\t\t\treturn !deviceIsAndroid;\n\t\tcase 'input':\n\t\t\tswitch (target.type) {\n\t\t\tcase 'button':\n\t\t\tcase 'checkbox':\n\t\t\tcase 'file':\n\t\t\tcase 'image':\n\t\t\tcase 'radio':\n\t\t\tcase 'submit':\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// No point in attempting to focus disabled inputs\n\t\t\treturn !target.disabled && !target.readOnly;\n\t\tdefault:\n\t\t\treturn (/\\bneedsfocus\\b/).test(target.className);\n\t\t}\n\t};\n\n\n\t/**\n\t * Send a click event to the specified element.\n\t *\n\t * @param {EventTarget|Element} targetElement\n\t * @param {Event} event\n\t */\n\tFastClick.prototype.sendClick = function(targetElement, event) {\n\t\tvar clickEvent, touch;\n\n\t\t// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\n\t\tif (document.activeElement && document.activeElement !== targetElement) {\n\t\t\tdocument.activeElement.blur();\n\t\t}\n\n\t\ttouch = event.changedTouches[0];\n\n\t\t// Synthesise a click event, with an extra attribute so it can be tracked\n\t\tclickEvent = document.createEvent('MouseEvents');\n\t\tclickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n\t\tclickEvent.forwardedTouchEvent = true;\n\t\ttargetElement.dispatchEvent(clickEvent);\n\t};\n\n\tFastClick.prototype.determineEventType = function(targetElement) {\n\n\t\t//Issue #159: Android Chrome Select Box does not open with a synthetic click event\n\t\tif (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {\n\t\t\treturn 'mousedown';\n\t\t}\n\n\t\treturn 'click';\n\t};\n\n\n\t/**\n\t * @param {EventTarget|Element} targetElement\n\t */\n\tFastClick.prototype.focus = function(targetElement) {\n\t\tvar length;\n\n\t\t// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.\n\t\tif (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {\n\t\t\tlength = targetElement.value.length;\n\t\t\ttargetElement.setSelectionRange(length, length);\n\t\t} else {\n\t\t\ttargetElement.focus();\n\t\t}\n\t};\n\n\n\t/**\n\t * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.\n\t *\n\t * @param {EventTarget|Element} targetElement\n\t */\n\tFastClick.prototype.updateScrollParent = function(targetElement) {\n\t\tvar scrollParent, parentElement;\n\n\t\tscrollParent = targetElement.fastClickScrollParent;\n\n\t\t// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the\n\t\t// target element was moved to another parent.\n\t\tif (!scrollParent || !scrollParent.contains(targetElement)) {\n\t\t\tparentElement = targetElement;\n\t\t\tdo {\n\t\t\t\tif (parentElement.scrollHeight > parentElement.offsetHeight) {\n\t\t\t\t\tscrollParent = parentElement;\n\t\t\t\t\ttargetElement.fastClickScrollParent = parentElement;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tparentElement = parentElement.parentElement;\n\t\t\t} while (parentElement);\n\t\t}\n\n\t\t// Always update the scroll top tracker if possible.\n\t\tif (scrollParent) {\n\t\t\tscrollParent.fastClickLastScrollTop = scrollParent.scrollTop;\n\t\t}\n\t};\n\n\n\t/**\n\t * @param {EventTarget} targetElement\n\t * @returns {Element|EventTarget}\n\t */\n\tFastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {\n\n\t\t// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.\n\t\tif (eventTarget.nodeType === Node.TEXT_NODE) {\n\t\t\treturn eventTarget.parentNode;\n\t\t}\n\n\t\treturn eventTarget;\n\t};\n\n\n\t/**\n\t * On touch start, record the position and scroll offset.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onTouchStart = function(event) {\n\t\tvar targetElement, touch, selection;\n\n\t\t// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).\n\t\tif (event.targetTouches.length > 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttargetElement = this.getTargetElementFromEventTarget(event.target);\n\t\ttouch = event.targetTouches[0];\n\n\t\tif (deviceIsIOS) {\n\n\t\t\t// Only trusted events will deselect text on iOS (issue #49)\n\t\t\tselection = window.getSelection();\n\t\t\tif (selection.rangeCount && !selection.isCollapsed) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!deviceIsIOS4) {\n\n\t\t\t\t// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):\n\t\t\t\t// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched\n\t\t\t\t// with the same identifier as the touch event that previously triggered the click that triggered the alert.\n\t\t\t\t// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an\n\t\t\t\t// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.\n\t\t\t\t// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,\n\t\t\t\t// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,\n\t\t\t\t// random integers, it's safe to to continue if the identifier is 0 here.\n\t\t\t\tif (touch.identifier && touch.identifier === this.lastTouchIdentifier) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthis.lastTouchIdentifier = touch.identifier;\n\n\t\t\t\t// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:\n\t\t\t\t// 1) the user does a fling scroll on the scrollable layer\n\t\t\t\t// 2) the user stops the fling scroll with another tap\n\t\t\t\t// then the event.target of the last 'touchend' event will be the element that was under the user's finger\n\t\t\t\t// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check\n\t\t\t\t// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).\n\t\t\t\tthis.updateScrollParent(targetElement);\n\t\t\t}\n\t\t}\n\n\t\tthis.trackingClick = true;\n\t\tthis.trackingClickStart = event.timeStamp;\n\t\tthis.targetElement = targetElement;\n\n\t\tthis.touchStartX = touch.pageX;\n\t\tthis.touchStartY = touch.pageY;\n\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.touchHasMoved = function(event) {\n\t\tvar touch = event.changedTouches[0], boundary = this.touchBoundary;\n\n\t\tif (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * Update the last position.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onTouchMove = function(event) {\n\t\tif (!this.trackingClick) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If the touch has moved, cancel the click tracking\n\t\tif (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {\n\t\t\tthis.trackingClick = false;\n\t\t\tthis.targetElement = null;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * Attempt to find the labelled control for the given label element.\n\t *\n\t * @param {EventTarget|HTMLLabelElement} labelElement\n\t * @returns {Element|null}\n\t */\n\tFastClick.prototype.findControl = function(labelElement) {\n\n\t\t// Fast path for newer browsers supporting the HTML5 control attribute\n\t\tif (labelElement.control !== undefined) {\n\t\t\treturn labelElement.control;\n\t\t}\n\n\t\t// All browsers under test that support touch events also support the HTML5 htmlFor attribute\n\t\tif (labelElement.htmlFor) {\n\t\t\treturn document.getElementById(labelElement.htmlFor);\n\t\t}\n\n\t\t// If no for attribute exists, attempt to retrieve the first labellable descendant element\n\t\t// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\n\t\treturn labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\n\t};\n\n\n\t/**\n\t * On touch end, determine whether to send a click event at once.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onTouchEnd = function(event) {\n\t\tvar forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;\n\n\t\tif (!this.trackingClick) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\n\t\t\tthis.cancelNextClick = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reset to prevent wrong click cancel on input (issue #156).\n\t\tthis.cancelNextClick = false;\n\n\t\tthis.lastClickTime = event.timeStamp;\n\n\t\ttrackingClickStart = this.trackingClickStart;\n\t\tthis.trackingClick = false;\n\t\tthis.trackingClickStart = 0;\n\n\t\t// On some iOS devices, the targetElement supplied with the event is invalid if the layer\n\t\t// is performing a transition or scroll, and has to be re-detected manually. Note that\n\t\t// for this to function correctly, it must be called *after* the event target is checked!\n\t\t// See issue #57; also filed as rdar://13048589 .\n\t\tif (deviceIsIOSWithBadTarget) {\n\t\t\ttouch = event.changedTouches[0];\n\n\t\t\t// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null\n\t\t\ttargetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;\n\t\t\ttargetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;\n\t\t}\n\n\t\ttargetTagName = targetElement.tagName.toLowerCase();\n\t\tif (targetTagName === 'label') {\n\t\t\tforElement = this.findControl(targetElement);\n\t\t\tif (forElement) {\n\t\t\t\tthis.focus(targetElement);\n\t\t\t\tif (deviceIsAndroid) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttargetElement = forElement;\n\t\t\t}\n\t\t} else if (this.needsFocus(targetElement)) {\n\n\t\t\t// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\n\t\t\t// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).\n\t\t\tif ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {\n\t\t\t\tthis.targetElement = null;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.focus(targetElement);\n\t\t\tthis.sendClick(targetElement, event);\n\n\t\t\t// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.\n\t\t\t// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)\n\t\t\tif (!deviceIsIOS || targetTagName !== 'select') {\n\t\t\t\tthis.targetElement = null;\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (deviceIsIOS && !deviceIsIOS4) {\n\n\t\t\t// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled\n\t\t\t// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).\n\t\t\tscrollParent = targetElement.fastClickScrollParent;\n\t\t\tif (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Prevent the actual click from going though - unless the target node is marked as requiring\n\t\t// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.\n\t\tif (!this.needsClick(targetElement)) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.sendClick(targetElement, event);\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * On touch cancel, stop tracking the click.\n\t *\n\t * @returns {void}\n\t */\n\tFastClick.prototype.onTouchCancel = function() {\n\t\tthis.trackingClick = false;\n\t\tthis.targetElement = null;\n\t};\n\n\n\t/**\n\t * Determine mouse events which should be permitted.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onMouse = function(event) {\n\n\t\t// If a target element was never set (because a touch event was never fired) allow the event\n\t\tif (!this.targetElement) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (event.forwardedTouchEvent) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Programmatically generated events targeting a specific element should be permitted\n\t\tif (!event.cancelable) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Derive and check the target element to see whether the mouse event needs to be permitted;\n\t\t// unless explicitly enabled, prevent non-touch click events from triggering actions,\n\t\t// to prevent ghost/doubleclicks.\n\t\tif (!this.needsClick(this.targetElement) || this.cancelNextClick) {\n\n\t\t\t// Prevent any user-added listeners declared on FastClick element from being fired.\n\t\t\tif (event.stopImmediatePropagation) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t} else {\n\n\t\t\t\t// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t\t\tevent.propagationStopped = true;\n\t\t\t}\n\n\t\t\t// Cancel the event\n\t\t\tevent.stopPropagation();\n\t\t\tevent.preventDefault();\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the mouse event is permitted, return true for the action to go through.\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * On actual clicks, determine whether this is a touch-generated click, a click action occurring\n\t * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\n\t * an actual click which should be permitted.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onClick = function(event) {\n\t\tvar permitted;\n\n\t\t// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\n\t\tif (this.trackingClick) {\n\t\t\tthis.targetElement = null;\n\t\t\tthis.trackingClick = false;\n\t\t\treturn true;\n\t\t}\n\n\t\t// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\n\t\tif (event.target.type === 'submit' && event.detail === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tpermitted = this.onMouse(event);\n\n\t\t// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.\n\t\tif (!permitted) {\n\t\t\tthis.targetElement = null;\n\t\t}\n\n\t\t// If clicks are permitted, return true for the action to go through.\n\t\treturn permitted;\n\t};\n\n\n\t/**\n\t * Remove all FastClick's event listeners.\n\t *\n\t * @returns {void}\n\t */\n\tFastClick.prototype.destroy = function() {\n\t\tvar layer = this.layer;\n\n\t\tif (deviceIsAndroid) {\n\t\t\tlayer.removeEventListener('mouseover', this.onMouse, true);\n\t\t\tlayer.removeEventListener('mousedown', this.onMouse, true);\n\t\t\tlayer.removeEventListener('mouseup', this.onMouse, true);\n\t\t}\n\n\t\tlayer.removeEventListener('click', this.onClick, true);\n\t\tlayer.removeEventListener('touchstart', this.onTouchStart, false);\n\t\tlayer.removeEventListener('touchmove', this.onTouchMove, false);\n\t\tlayer.removeEventListener('touchend', this.onTouchEnd, false);\n\t\tlayer.removeEventListener('touchcancel', this.onTouchCancel, false);\n\t};\n\n\n\t/**\n\t * Check whether FastClick is needed.\n\t *\n\t * @param {Element} layer The layer to listen on\n\t */\n\tFastClick.notNeeded = function(layer) {\n\t\tvar metaViewport;\n\t\tvar chromeVersion;\n\t\tvar blackberryVersion;\n\t\tvar firefoxVersion;\n\n\t\t// Devices that don't support touch don't need FastClick\n\t\tif (typeof window.ontouchstart === 'undefined') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Chrome version - zero for other browsers\n\t\tchromeVersion = +(/Chrome\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\n\n\t\tif (chromeVersion) {\n\n\t\t\tif (deviceIsAndroid) {\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\n\t\t\t\tif (metaViewport) {\n\t\t\t\t\t// Chrome on Android with user-scalable=\"no\" doesn't need FastClick (issue #89)\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Chrome 32 and above with width=device-width or less don't need FastClick\n\t\t\t\t\tif (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Chrome desktop doesn't need FastClick (issue #15)\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (deviceIsBlackBerry10) {\n\t\t\tblackberryVersion = navigator.userAgent.match(/Version\\/([0-9]*)\\.([0-9]*)/);\n\n\t\t\t// BlackBerry 10.3+ does not require Fastclick library.\n\t\t\t// https://github.com/ftlabs/fastclick/issues/251\n\t\t\tif (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\n\t\t\t\tif (metaViewport) {\n\t\t\t\t\t// user-scalable=no eliminates click delay.\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// width=device-width (or less than device-width) eliminates click delay.\n\t\t\t\t\tif (document.documentElement.scrollWidth <= window.outerWidth) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)\n\t\tif (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Firefox version - zero for other browsers\n\t\tfirefoxVersion = +(/Firefox\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\n\n\t\tif (firefoxVersion >= 27) {\n\t\t\t// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896\n\n\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\t\t\tif (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version\n\t\t// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx\n\t\tif (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * Factory method for creating a FastClick object\n\t *\n\t * @param {Element} layer The layer to listen on\n\t * @param {Object} [options={}] The options to override the defaults\n\t */\n\tFastClick.attach = function(layer, options) {\n\t\treturn new FastClick(layer, options);\n\t};\n\n\n\tif (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine(function() {\n\t\t\treturn FastClick;\n\t\t});\n\t} else if (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = FastClick.attach;\n\t\tmodule.exports.FastClick = FastClick;\n\t} else {\n\t\twindow.FastClick = FastClick;\n\t}\n}());\n"},292:function(n,e,t){"use strict";t(0)(t(293))},293:function(n,e){n.exports="spweb.utils = (function() {\n    /**\n     * Utility methods\n     * @module spweb/utils\n     */\n\n    'use strict';\n\n    var exports = {\n\n        /**\n         * Counts the items in an object\n         * @param {Object} obj\n         * @returns {Number}\n         */\n        objectLength: function(obj) {\n            var size = 0, key;\n            for (key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    size++;\n                }\n            }\n            return size;\n        },\n\n        /**\n         * Query string based off:\n         * http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values\n         * @param {String} name query string key\n         * @param {String} [qs] A query string to search through instead of the default current url\n         * @return {String} value of the queried key in the query string. Returns an empty string of the\n         *  key does not exist\n         */\n        getQueryParameter: function(name, qs) {\n            qs = qs || window.location.search;\n            name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\n            var regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)'),\n                results = regex.exec(qs);\n            return results == null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' '));\n        },\n\n        /**\n         * Redirect the browser\n         * @param {String} url New browser location\n         */\n        redirect: function(url) {\n            window.location.href = url;\n        },\n\n        /**\n         * @description Returns a random integer between min and max\n         * @param {Number} min The lower range of integers to select\n         *  a random integer from.\n         * @param {Number} max The upper range of integers to select\n         *  a random integer from.\n         * @returns {Number} A random integer.\n         */\n        getRandomInt: function (min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n\n        /**\n         * @description Loads a JS script into the DOM asynchronously\n         * @param {String} src URI of the JS script\n         * @param {Function} [callback] Function to call once script has loaded\n         */\n        asyncLoadJs: function (src, callback) {\n            var cb = (typeof callback === 'function') ? callback : false,\n                document = document || window.document,\n                script = document.createElement('script'),\n                s = document.getElementsByTagName('script')[0];\n\n            script.async = 'async';\n            script.src = src;\n\n            script.onload = script.onreadystatechange = function() {\n                if (script.readyState) {\n                    if (script.readyState === 'loaded' || script.readyState === 'complete') {\n                        script.onreadystatechange = null;\n                        if (cb) {\n                            cb();\n                        }\n                    }\n                } else {\n                    if (cb) {\n                        cb();\n                    }\n                }\n            };\n            s.parentNode.insertBefore(script, s);\n        },\n\n        /**\n         * Helper for Javascript inheritance from https://wiki.spotify.net/wiki/Architecture/Client/Stitch/Classes_and_inheritance\n         * @param {Function} cls\n         * @param {Function} superclass\n         */\n        inherit: function(cls, superclass) {\n            function F() {}\n            F.prototype = superclass.prototype;\n            cls.prototype = new F();\n            cls.prototype.constructor = cls;\n        },\n\n        /**\n         * Shuffle an array\n         *\n         * @param {Array} array\n         * @returns {Array}\n         */\n        shuffle: function (array) {\n            var i, j, tmp;\n\n            // Randomize the array\n            for (i = array.length - 1; i > 0; i--) {\n                j = Math.floor(Math.random() * (i + 1));\n                tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n            }\n\n            return array;\n        },\n\n        /**\n         * Function that updates a div's lazy load image source depending on screen width\n         * Works in conjunction with http://www.appelsiini.net/projects/lazyload\n         */\n        updateLazyLoadImages: function() {\n            var isMobileView = !('matchMedia' in window) || !window.matchMedia(\"(min-width: 768px)\").matches;\n\n            // NOTE: we are only looping over div tags\n            $('div.lazy').each(function(index) {\n                var newOriginal,\n                    $this = $(this);\n\n                // Skip elements with \"lazy-no-small\" CSS class\n                if ($this.hasClass('lazy-no-small')) {\n                    return;\n                }\n\n                if (isMobileView && $this.attr('data-original').indexOf('-sm') < 0) {\n                    newOriginal = $this.attr('data-original').replace('.jpg', '-sm.jpg').replace('.png', '-sm.png');\n                    $this.attr('data-original', newOriginal);\n                }\n\n                if (!isMobileView && $this.attr('data-original').indexOf('-sm') > 0) {\n                    newOriginal = $this.attr('data-original').replace('-sm.jpg', '.jpg').replace('-sm.png', '.png');\n                    $this.attr('data-original', newOriginal);\n                }\n\n                // Only update if we have a new original to update with,\n                //   and only if the background-image was already set.\n                if ($this.css('background-image') !== 'none' && newOriginal !== undefined) {\n                    $this.css('background-image', 'url(' + newOriginal + ')');\n                }\n            });\n        },\n\n        /**\n         * Redirect user to /signup/ and append forward_url query param to url\n         * Works as a click event handler bound to an anchor with an href attribute.\n         * The href attribute will be encoded and set as the forward_url query parameter's value\n         * @param {object} e the generated jQuery event object\n         */\n\n        goToSignup: function(e) {\n            var forwardUrl;\n            e.preventDefault();\n\n            forwardUrl = $(this).attr('href');\n            if (forwardUrl[0] !== '/') {\n                forwardUrl = '/' + forwardUrl;\n            }\n            window.location = '/' + spweb.user.getMarket() + '/signup/?forward_url=' + window.encodeURIComponent(window.location.origin + forwardUrl);\n        },\n\n\n\n    autoLogin : function(callback) {\n      if (_allowDesktopRedirect() && !_autoLoginDisabledByQuery()) {\n        var remote = new spweb.remotecontrol({\n          token: spweb.config.autologin.remotetoken,\n          pollClient: true,\n          retryConnect: true,\n          reconnectOnLogout: true,\n          autoOpen: false\n        });\n        remote.connect()\n          .then(function(status) {\n            remote.getWebToken()\n              .then(function(response) {\n                if (response.web_token) {\n                  spweb.config.autologin.token = response.web_token;\n                  if (callback) {\n                    callback();\n                  }\n                }\n              }, function(reason) {\n                if (callback) {\n                  callback();\n                }\n              });\n            }, function(reason) {\n              if (callback) {\n                callback();\n              };\n            });\n        } else {\n          if (callback) {\n          callback();\n        }\n      }\n    }\n  };\n\n    return exports;\n\n}());\n"},294:function(n,e,t){"use strict";t(0)(t(295))},295:function(n,e){n.exports="spweb.user = (function($) {\n  /**\n   * The user module describes characteristics about the user such as\n   * preferred language, market, logged in state.\n   *\n   * @module spweb/user\n   * @requires jQuery\n   */\n\n  'use strict';\n\n  var _lang = null,\n    _market = null,\n\n    exports = {};\n\n  /**\n   * @returns {String} language\n   */\n  exports.getLang = function() {\n    if (_lang === null) {\n      _lang = $('body')\n      .attr('class')\n      .match(/l-([\\w]+)/)[1];\n    }\n    return _lang;\n  };\n\n  /**\n   * @returns {String} market\n   */\n  exports.getMarket = function() {\n    if (_market === null) {\n      _market = $('body')\n      .attr('class')\n      .match(/m-([\\w-]+)/)[1];\n    }\n    return _market;\n  };\n\n  /**\n   * @returns {Boolean} is the user logged in?\n   */\n  exports.isLoggedIn = function() {\n    return $('body').hasClass('is-loggedin');\n  };\n\n  return exports;\n\n}(jQuery));\n"},296:function(n,e,t){"use strict";t(0)(t(297))},297:function(n,e){n.exports="/*eslint no-unused-expressions:0*/\nspweb.securityMonitor = (function ($, user) {\n  /**\n   * Naive XSS monitor\n   * @Module spweb/securityMonitor\n   * @requires jQuery\n   * @requires spweb.user\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  var _doLog = function(logType, args) {\n    var security;\n\n    try {\n      security.XY.Z;\n    } catch (e) {\n      var logData = {\n        'args': args,\n        'browser': window.navigator.userAgent,\n        'url': window.location.href,\n        'referrer': document.referrer,\n        'trace': e.stack || 'N/A'\n      };\n      $.ajax({\n        type: 'POST',\n        url: '/' + user.getMarket() + '/xhr/json/tracking.php',\n        data: {\n          'event': 'SecurityWarning',\n          'params': JSON.stringify({\n            'type': logType + ':web-site',\n            'log_data': logData\n          })\n        }\n      });\n\n      $.ajax({\n        type: 'POST',\n        url: '/' + user.getMarket() + '/xhr/json/security-monitor.php',\n        data: {\n          'site': window.location.origin,\n          'method': logType,\n          'data': JSON.stringify(logData)\n        }\n      });\n    }\n  };\n\n  exports.init = function() {\n    // Wrapping funcs in a naive attempt to catch externally found XSS vulns\n    (function(fn) {\n      window.alert = function() {\n        var args = Array.prototype.slice.call(arguments);\n        _doLog('alert', args);\n        return fn.apply(window, args);\n      };\n    }(window.alert));\n\n    (function(fn) {\n      window.prompt = function() {\n        var args = Array.prototype.slice.call(arguments);\n        _doLog('prompt', args);\n        return fn.apply(window, args);\n      };\n    }(window.prompt));\n\n    (function(fn) {\n      window.confirm = function() {\n        var args = Array.prototype.slice.call(arguments);\n        _doLog('confirm', args);\n        return fn.apply(window, args);\n      };\n    }(window.confirm));\n  };\n\n  return exports;\n}(jQuery, spweb.user));\n"},298:function(n,e,t){"use strict";t(0)(t(299))},299:function(n,e){n.exports='spweb.detect = (function () {\n  /**\n   * REMEMBER, this library is also exists in PHP in the php/web-core\n   * project. Please remember to keep them in sync:\n   *\n   * https://ghe.spotify.net/php/web-core/blob/master/lib/Spotify/Core/Detect.php\n   */\n\n  /**\n   * Detects the OS of the device by sniffing the user agent.\n   *\n   * @module spweb/detect\n   */\n\n  \'use strict\';\n\n  var exports = {};\n\n  exports.OS_WPHONE = \'wphone\';\n  exports.OS_ANDROID = \'android\';\n  exports.OS_IOS = \'ios\';\n  exports.OS_MAC = \'mac\';\n  exports.OS_LINUX = \'linux\';\n  exports.OS_CHROMEOS = \'chromeos\';\n  exports.OS_WINDOWS = \'windows\';\n  exports.OS_BLACKBERRY = \'blackberry\';\n  exports.OS_KINDLE = \'kindle\';\n  exports.OS_SYMBIAN = \'symbian\';\n  exports.OS_UNKNOWN = \'unknown\';\n\n  /**\n   *\n   * The detect function provides a best-guess of the OS based on the\n   * provided User Agent string. Returned is an array:\n   *\n   * "os"     => string - wphone, android, ios, mac, unknown, linux, chromeos,\n   *                      windows, blackberry, kindle, symbian\n   * "mobile" => bool   - is this a mobile OS?\n   *\n   * It is important to remember that the "mobile" part of the response is\n   * not trying to work out the form-factor of the device. We don\'t\n   * differentiate between mobiles and tablets, and there are plenty of edge\n   * case devices (e.g. Android laptops) that run a mobile OS on a desktop\n   * style platform.\n   *\n   * As time goes on, there will probably be more and more of these\n   * cross-over devices, so be careful.\n   *\n   * mobile == true: android, ios, wphone, blackberry, kindle, symbian\n   * mobile == false: mac, windows, chromeos, linux\n   *\n   * The "unknown" OS is a catch-all for several types of device. Some e.g.\n   * smart tv\'s are mobile == false. Some e.g. Samsung Tizen mobiles are\n   * mobile == true.\n   *\n   * @param [ua]\n   * @returns {*}\n   */\n  exports.detect = function (ua) {\n    var i, spec, reg, data, test;\n\n    if (ua === null) {\n      ua = window.navigator.userAgent;\n    }\n\n    data = getData();\n\n    // Build the string to match - note we add a space either end so we can\n    // match \\b at the start and end of the string\n    test = " " + ua + " ";\n\n    for (i = 0; i < data.length; i++) {\n      spec = data[i];\n\n      // Build a regex by concatinating the matches with \\b (word boundry)\n      // either side.\n      reg = new RegExp("\\\\b" + spec["matches"].join("\\\\b|\\\\b") + "\\\\b");\n\n      if (reg.test(test)) {\n        return {"os": spec["os"], "mobile": spec["mobile"]};\n      }\n    }\n    return {"os": exports.OS_UNKNOWN, "mobile": false};\n  };\n\n  /**\n   * Gets data for mobile detection. This data is used by the web-core\n   * Detect::detect function, and also the javascript spweb.detect class.\n   *\n   * @return array\n   */\n  function getData() {\n    return [\n      {\n        "note": "Windows Phone: pretends to be iPhone and Android, so it has to stay first in the list",\n        "os": exports.OS_WPHONE,\n        "mobile": true,\n        "matches": ["Windows Phone", "Windows CE", "Window Mobile", "XBLWP7", "ZuneWP7", "Windows NT \\\\d{1,2}\\\\.\\\\d{1,2}; ARM", "IEMobile"]\n      },\n      {\n        "note": "Google Android",\n        "os": exports.OS_ANDROID,\n        "mobile": true,\n        "matches": ["Android"]\n      },\n      {\n        "note": "Apple iOS",\n        "os": exports.OS_IOS,\n        "mobile": true,\n        "matches": ["iPhone", "iPod", "iPad", "MobileSafari", "CriOS"]\n      },\n      {\n        "note": "Apple Mac OS X",\n        "os": exports.OS_MAC,\n        "mobile": false,\n        "matches": ["Mac OS X"]\n      },\n      {\n        "note": "Mobile games consoles",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["PlayStation Vita", "Nintendo WiiU", "Nintendo 3DS"]\n      },\n      {\n        "note": "TV games consoles",\n        "os": exports.OS_UNKNOWN,\n        "mobile": false,\n        "matches": ["PlayStation 4", "PLAYSTATION 3"]\n      },\n      {\n        "note": "Smart TVs",\n        "os": exports.OS_UNKNOWN,\n        "mobile": false,\n        "matches": ["SMART-TV", "SmartTV", "NETTV", "PhilipsTV", "GoogleTV", "HbbTV", "AQUOSBrowser", "BRAVIA", "SonyBDP", "Viera"]\n      },\n      {\n        "note": "Linux Desktop: Firefox is not very clear on Linux/FirefoxOS, but we assume Intel platform is desktop Linux, and ARM is mobile.",\n        "os": exports.OS_LINUX,\n        "mobile": false,\n        "matches": ["Linux i686"]\n      },\n      {\n        "note": "Firefox OS (mobile): Firefox is not very clear on Linux/FirefoxOS, but we assume Intel platform is desktop Linux, and ARM is mobile.",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["Linux armv7l"]\n      },\n      {\n        "note": "Google Chrome OS",\n        "os": exports.OS_CHROMEOS,\n        "mobile": false,\n        "matches": ["CrOS"]\n      },\n      {\n        "note": "Microsoft Windows",\n        "os": exports.OS_WINDOWS,\n        "mobile": false,\n        "matches": ["Windows", "Win64"]\n      },\n      {\n        "note": "BlackBerry",\n        "os": exports.OS_BLACKBERRY,\n        "mobile": true,\n        "matches": ["PlayBook", "RIM Tablet", "blackberry", "BlackBerry", "BB10", "rim tablet os"]\n      },\n      {\n        "note": "Samsung Mobile OS variants",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["Bada", "Tizen", "SpreadTrum"]\n      },\n      {\n        "note": "Amazon Kindle (forked Android that needs a separate app store link)",\n        "os": exports.OS_KINDLE,\n        "mobile": true,\n        "matches": ["Kindle", "Silk"]\n      },\n      {\n        "note": "Nokia Symbian",\n        "os": exports.OS_SYMBIAN,\n        "mobile": true,\n        "matches": ["nokian73", "S60V3", "Series 60", "SymbOS", "SymbianOS"]\n      },\n      {\n        "note": "Java Mobile: Various low-cost smart phones",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["J2ME", "MIDP", "CLDC"]\n      },\n      {\n        "note": "UCBrowser: this seems to be quite popular on several platforms, but its impossible to tell them apart. We should probably assume Android?",\n        "os": exports.OS_ANDROID,\n        "mobile": true,\n        "matches": ["UCBrowser", "UCWEB", "UCWEB\\\\d"]\n      },\n      {\n        "note": "If we havent detected anything by this point, we should look for some generic indications that we have a mobile device.",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["Mobile", "Tablet", "Opera Mini"]\n      },\n      {\n        "note": "Final match for linux desktop",\n        "os": exports.OS_LINUX,\n        "mobile": false,\n        "matches": ["Linux"]\n      }\n    ];\n  }\n\n  return exports;\n\n}());'},300:function(n,e,t){"use strict";t(0)(t(301))},301:function(n,e){n.exports="spweb.tracking = (function(globals, $, detect) {\n  /**\n   * @module spweb/tracking\n   * @requires this (the global context, eg, window)\n   * @requires jQuery\n   * @requires spweb.detect\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * Forward \"interesting\" events on to our tracking systems - eg Google Tag Manager,\n   * backend logging, etc.\n   * @param {String} eventName\n   */\n  exports.pushGTMEvent = function(eventName) {\n    globals.dataLayer.push({event: eventName});\n  };\n\n  /**\n   * Subscribe to custom events\n   */\n  $.subscribe('registration_success', function() {\n    exports.pushGTMEvent('registration_success');\n  });\n\n  /**\n   * Module set up\n   */\n  exports.init = function() {\n    // check if GTM is present and functions are available before\n    // calling them.\n    if (globals.hasOwnProperty('dataLayer')) {\n      this._setGTMDeviceData();\n      this._bindEventHandlers();\n    }\n  };\n\n  /**\n   * Pushes device key/value to Google Tag Manager (GTM) dataLayer array\n   */\n  exports._setGTMDeviceData = function() {\n    globals.dataLayer.push({device: detect.detect().mobile ? 'mobile' : 'desktop'});\n  };\n\n  /**\n   * @private\n   */\n  exports._bindEventHandlers = function() {\n    var self = this;\n\n    $('.js-gtm-event').on('click', function() {\n      var jqEl = $(this);\n      self._handleGTMClick(jqEl);\n    });\n  };\n\n  /**\n   * Handle click events on elements related to Google Tag Manager (GTM)\n   * @private\n   * @param {Object} el the clicked element as a jQuery object\n   */\n  exports._handleGTMClick = function(el) {\n    var name = el.data('gtm-event-name');\n    if (name !== undefined) {\n      exports.pushGTMEvent(name);\n    }\n  };\n\n  return exports;\n\n}(typeof global !== 'undefined' ? global : window, jQuery, spweb.detect));\n"},302:function(n,e,t){"use strict";t(0)(t(303))},303:function(n,e){n.exports="spweb.download = (function ($, cookie) {\n  /**\n   * Behavior related to the downloads page.\n   * @module spweb/download\n   * @requires jQuery\n   * @requires spweb.cookie\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * Trigger download; remove tracking pixel\n   * @param {String} url\n   * @param {Number} delay (ms)\n   */\n  exports.download = function(url, delay) {\n    $(document).ready(function(){\n      setTimeout(function() {\n        window.location.href = url;\n      }, delay);\n    });\n    // Remove the tracking pixel\n    cookie.remove('pxt');\n  };\n\n  return exports;\n\n}(jQuery, spweb.cookie));\n"},304:function(n,e,t){"use strict";t(0)(t(305))},305:function(n,e){n.exports="spweb.messageBars = (function ($, cookie) {\n\n  /**\n   * Manage message bar ui components\n   * @module spweb/messageBars\n   * @requires jQuery\n   * @requires spweb.cookie\n   */\n\n  'use strict';\n\n  var exports = {\n    /**\n     * The active messages collection keeps a record of the currently active message bars. This is\n     * used to tweak the padding of the .wrap element to ensure the header doesn't collide with\n     * the content.\n     */\n    active: {},\n\n    /**\n     * Initialises all the message bars\n     */\n    init: function() {\n\n      // This is a div in which all the message bars are contained\n      spweb.messageBars.holder = $('#js-message-bars');\n\n      // Initialize message bars\n      for (var messageBar in spweb.messageBars) {\n        spweb.messageBars.initMessageBar(messageBar);\n      }\n    },\n\n    /**\n     * Initialize a message bar\n     * @param {Object} messageBar\n     */\n    initMessageBar: function(messageBar) {\n      if (spweb.messageBars[messageBar] && spweb.messageBars[messageBar].name && spweb.messageBars[messageBar].selector) {\n\n        spweb.messageBars[messageBar].element = $(spweb.messageBars[messageBar].selector);\n\n        // If the element doesn't exist in the HTML, don't continue\n        if (spweb.messageBars[messageBar].element.length === 0) {\n          return;\n        }\n\n        // If we have the cookie, don't show the message\n        if (cookie.get(spweb.messageBars[messageBar].name)) {\n          return;\n        }\n\n        /**\n         * Show method should only be called in messages.add\n         * @private\n         */\n        spweb.messageBars[messageBar]._show = function() {\n          spweb.messageBars[messageBar].element.removeClass('hidden');\n        };\n\n        /**\n         * Hide method should only be called in messages.remove\n         * @private\n         */\n        spweb.messageBars[messageBar]._hide = function() {\n          spweb.messageBars[messageBar].element.addClass('hidden');\n        };\n\n        // Add the object to the active messages collection\n        spweb.messageBars.add(spweb.messageBars[messageBar]);\n\n        // Enables the bootstrap dismiss button\n        spweb.messageBars[messageBar].element.alert();\n\n        // Ties up the bootstrap alert close event\n        spweb.messageBars[messageBar].element.on('closed.bs.alert', function() {\n          // Sets the cookie so we don't show the message on subsequest page views. Note we don't\n          // want to call the alert close method here because we're navigating away from the page\n          // and hiding the message bar just before navigating looks a bit strange.\n          var cookieData = {\n            name: spweb.messageBars[messageBar].name,\n            value: '1'\n          }\n\n          if(spweb.messageBars[messageBar].multiDomainCookie) {\n            cookieData.domain = '.' + window.location.host.split('.').splice(1).join('.');\n          }\n\n          if(spweb.messageBars[messageBar].cookieExpirationDays) {\n            cookieData.expires = spweb.messageBars[messageBar].cookieExpirationDays;\n          }\n\n          cookie.set(cookieData);\n\n          // Remove the object from the active messages collection\n          spweb.messageBars.remove(spweb.messageBars[messageBar]);\n\n          // Do message-specific post-close stuff if need be\n          if (typeof spweb.messageBars[messageBar].onClose === 'function') {\n            spweb.messageBars[messageBar].onClose();\n          }\n        });\n\n        // Do message-specific initialization if need be\n        if (typeof spweb.messageBars[messageBar].init === 'function') {\n          spweb.messageBars[messageBar].init();\n        }\n      }\n    },\n\n    /**\n     * Add a message bar to the active messages collection and show it. We also\n     * fire the message_bars_shown event.\n     * @param {Object} message\n     */\n    add: function(message) {\n      spweb.messageBars.active[message.name] = message;\n      message._show();\n      $.publish('message_bars_shown');\n    },\n\n    /**\n     * Remove a message bar from the active messages collection and hide it.\n     * If there are no active message bars left, we fore the message_bars_hidden\n     * event. Note we also fire the message_bars_shown event if there are still\n     * message bars because we're not 100% certain that the page starts off in the\n     * right state.\n     * @param {Object} message\n     */\n    remove: function(message) {\n      delete spweb.messageBars.active[message.name];\n      message._hide();\n      if (spweb.messageBars.hasItem()) {\n        $.publish('message_bars_shown');\n      } else {\n        $.publish('message_bars_hidden');\n      }\n    },\n\n    /**\n     * Is there an active message bar?\n     * @returns {boolean}\n     */\n    hasItem: function() {\n      var key;\n      for (key in spweb.messageBars.active) {\n        if (spweb.messageBars.active.hasOwnProperty(key)) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    /**\n     * Thai day of mourning bar - as a kludge this also includes the multi-language text.\n     */\n    thaiDom: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'thanDom',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-thai-dom',\n\n      /**\n       * Initialise the thaiDom message bar\n       */\n      init: function() {\n\n        // Ties to the multi-language change link\n        $('.multi-language-link').unbind('click.messageBars').bind('click.messageBars', function() {\n\n          // Calls the update-preferred-locale endpoint to save the new market to the\n          // preferred-locale user atribute. Note if there's an error we don't want to interrupt\n          // the redirect, so we don't bother waiting for the response.\n          $.get('/' + spweb.messageBars.thaiDom.element.data('alternative-market') + '/update-preferred-locale/');\n\n        });\n      }\n    },\n\n    /**\n     * Multi language bar: in multi-language markets (CH, CA, HK etc.), this prompts the visitor to\n     * change language.\n     */\n    multiLanguage: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'multiLanguage',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-multi-language',\n\n      /**\n       * Initialise the multiLanguage message bar\n       */\n      init: function() {\n\n        // Ties to the multi-language change link\n        $('.multi-language-link').unbind('click.messageBars').bind('click.messageBars', function() {\n\n          // Calls the update-preferred-locale endpoint to save the new market to the\n          // preferred-locale user atribute. Note if there's an error we don't want to interrupt\n          // the redirect, so we don't bother waiting for the response.\n          $.get('/' + spweb.messageBars.multiLanguage.element.data('alternative-market') + '/update-preferred-locale/');\n\n        });\n      }\n    },\n\n    /**\n     * Cookie notice bar: in certain markets, this warns the user that the site uses cookies.\n     */\n    cookieNotice: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'cookieNotice',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-cookie-notice',\n\n      /**\n       * Specify if cookie should exclude subdomain\n       */\n      multiDomainCookie: true,\n\n      /**\n       * Set cookie expiration\n       */\n      cookieExpirationDays: 90\n    },\n\n    /**\n     * Cookie authorization bar: in certain markets, users need to authorized third party cookies.\n     */\n    cookieAuthorization: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'sp_tpc',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-cookie-authorization',\n\n      /**\n       * Specify if cookie should exclude subdomain\n       */\n      multiDomainCookie: false,\n\n      /**\n       * Set cookie expiration\n       */\n      cookieExpirationDays: 365,\n\n      /**\n       * Perform post-close tasks\n       */\n      onClose: function() {\n        window.location.reload();\n      }\n    },\n\n    /**\n     * Special notice bar: warns the user with some arbitrary message.\n     */\n    specialNotice: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'specialNotice',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-special-notice'\n    }\n\n  };\n\n  return exports;\n\n}(jQuery, spweb.cookie));\n"},306:function(n,e,t){"use strict";t(0)(t(307))},307:function(n,e){n.exports="spweb.navbar = (function ($) {\n  /**\n   * navbar disables / enables the sticky navbar when we add / remove message bars.\n   *\n   * @module spweb/navbar\n   * @requires jQuery\n   */\n\n  'use strict';\n\n  var exports = {},\n    fixedClass = 'navbar-fixed-top',\n    staticClass = 'navbar-static-top',\n    dataTag = 'navbar-fixed-top-disabled';\n\n  /**\n   * Fires when message_bars_shown is published\n   * @private\n   */\n  exports._shown = function() {\n    var navbar = $('#js-navbar');\n    if (navbar.length === 0) {\n      return;\n    }\n\n    // We use a data attribute to record if the navbar wants to be in fixed mode, so\n    // we can put it back in fixed mode in the message_bars_hidden event.\n    if (navbar.hasClass(fixedClass)) {\n      navbar\n        .removeClass(fixedClass)\n        .addClass(staticClass)\n        .data(dataTag, true);\n    }\n  };\n\n  /**\n   * Fires when message_bars_hidden is published\n   * @private\n   */\n  exports._hidden = function() {\n    var navbar = $('#js-navbar');\n    if (navbar.length === 0) {\n      return;\n    }\n\n    // We only make it fixed if we've set the data attribute in the message_bars_shown\n    // event.\n    if (navbar.data(dataTag) === true) {\n      navbar\n        .addClass(fixedClass)\n        .removeClass(staticClass)\n        .data(dataTag, false);\n    }\n  };\n\n  /**\n   * Initialise - note this must run before spweb.messageBars.init().\n   */\n  exports.init = function() {\n    // If we have shown the message bars, and if the navbar wants to be\n    // fixed, we disable the fixed.\n    $.subscribe('message_bars_shown', function(){\n      exports._shown();\n    });\n\n    // If we have hidden the message bars, and if the navbar wants to be\n    // fixed, we make it fixed.\n    $.subscribe('message_bars_hidden', function(){\n      exports._hidden();\n    });\n  };\n\n  return exports;\n\n}(jQuery));\n"},308:function(n,e,t){"use strict";t(0)(t(309))},309:function(n,e){n.exports='/*!\n * jQuery Validation Plugin 1.11.1\n *\n * http://bassistance.de/jquery-plugins/jquery-plugin-validation/\n * http://docs.jquery.com/Plugins/Validation\n *\n * Copyright 2013 Jörn Zaefferer\n * Released under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n */\n\n(function($) {\n\n  $.extend($.fn, {\n    // http://docs.jquery.com/Plugins/Validation/validate\n    validate: function( options ) {\n\n      // if nothing is selected, return nothing; can\'t chain anyway\n      if ( !this.length ) {\n        if ( options && options.debug && window.console ) {\n          console.warn( "Nothing selected, can\'t validate, returning nothing." );\n        }\n        return;\n      }\n\n      // check if a validator for this form was already created\n      var validator = $.data( this[0], "validator" );\n      if ( validator ) {\n        return validator;\n      }\n\n      // Add novalidate tag if HTML5.\n      this.attr( "novalidate", "novalidate" );\n\n      validator = new $.validator( options, this[0] );\n      $.data( this[0], "validator", validator );\n\n      if ( validator.settings.onsubmit ) {\n\n        this.validateDelegate( ":submit", "click", function( event ) {\n          if ( validator.settings.submitHandler ) {\n            validator.submitButton = event.target;\n          }\n          // allow suppressing validation by adding a cancel class to the submit button\n          if ( $(event.target).hasClass("cancel") ) {\n            validator.cancelSubmit = true;\n          }\n\n          // allow suppressing validation by adding the html5 formnovalidate attribute to the submit button\n          if ( $(event.target).attr("formnovalidate") !== undefined ) {\n            validator.cancelSubmit = true;\n          }\n        });\n\n        // validate the form on submit\n        this.submit( function( event ) {\n          if ( validator.settings.debug ) {\n            // prevent form submit to be able to see console output\n            event.preventDefault();\n          }\n          function handle() {\n            var hidden;\n            if ( validator.settings.submitHandler ) {\n              if ( validator.submitButton ) {\n                // insert a hidden input as a replacement for the missing submit button\n                hidden = $("<input type=\'hidden\'/>").attr("name", validator.submitButton.name).val( $(validator.submitButton).val() ).appendTo(validator.currentForm);\n              }\n              validator.settings.submitHandler.call( validator, validator.currentForm, event );\n              if ( validator.submitButton ) {\n                // and clean up afterwards; thanks to no-block-scope, hidden can be referenced\n                hidden.remove();\n              }\n              return false;\n            }\n            return true;\n          }\n\n          // prevent submit for invalid forms or custom submit handlers\n          if ( validator.cancelSubmit ) {\n            validator.cancelSubmit = false;\n            return handle();\n          }\n          if ( validator.form() ) {\n            if ( validator.pendingRequest ) {\n              validator.formSubmitted = true;\n              return false;\n            }\n            return handle();\n          } else {\n            validator.focusInvalid();\n            return false;\n          }\n        });\n      }\n\n      return validator;\n    },\n    // http://docs.jquery.com/Plugins/Validation/valid\n    valid: function() {\n      if ( $(this[0]).is("form")) {\n        return this.validate().form();\n      } else {\n        var valid = true;\n        var validator = $(this[0].form).validate();\n        this.each(function() {\n          valid = valid && validator.element(this);\n        });\n        return valid;\n      }\n    },\n    // attributes: space seperated list of attributes to retrieve and remove\n    removeAttrs: function( attributes ) {\n      var result = {},\n        $element = this;\n      $.each(attributes.split(/\\s/), function( index, value ) {\n        result[value] = $element.attr(value);\n        $element.removeAttr(value);\n      });\n      return result;\n    },\n    // http://docs.jquery.com/Plugins/Validation/rules\n    rules: function( command, argument ) {\n      var element = this[0];\n\n      if ( command ) {\n        var settings = $.data(element.form, "validator").settings;\n        var staticRules = settings.rules;\n        var existingRules = $.validator.staticRules(element);\n        switch(command) {\n          case "add":\n            $.extend(existingRules, $.validator.normalizeRule(argument));\n            // remove messages from rules, but allow them to be set separetely\n            delete existingRules.messages;\n            staticRules[element.name] = existingRules;\n            if ( argument.messages ) {\n              settings.messages[element.name] = $.extend( settings.messages[element.name], argument.messages );\n            }\n            break;\n          case "remove":\n            if ( !argument ) {\n              delete staticRules[element.name];\n              return existingRules;\n            }\n            var filtered = {};\n            $.each(argument.split(/\\s/), function( index, method ) {\n              filtered[method] = existingRules[method];\n              delete existingRules[method];\n            });\n            return filtered;\n        }\n      }\n\n      var data = $.validator.normalizeRules(\n        $.extend(\n          {},\n          $.validator.classRules(element),\n          $.validator.attributeRules(element),\n          $.validator.dataRules(element),\n          $.validator.staticRules(element)\n        ), element);\n\n      // make sure required is at front\n      if ( data.required ) {\n        var param = data.required;\n        delete data.required;\n        data = $.extend({required: param}, data);\n      }\n\n      return data;\n    }\n  });\n\n// Custom selectors\n  $.extend($.expr[":"], {\n    // http://docs.jquery.com/Plugins/Validation/blank\n    blank: function( a ) { return !$.trim("" + $(a).val()); },\n    // http://docs.jquery.com/Plugins/Validation/filled\n    filled: function( a ) { return !!$.trim("" + $(a).val()); },\n    // http://docs.jquery.com/Plugins/Validation/unchecked\n    unchecked: function( a ) { return !$(a).prop("checked"); }\n  });\n\n// constructor for validator\n  $.validator = function( options, form ) {\n    this.settings = $.extend( true, {}, $.validator.defaults, options );\n    this.currentForm = form;\n    this.init();\n  };\n\n  $.validator.format = function( source, params ) {\n    if ( arguments.length === 1 ) {\n      return function() {\n        var args = $.makeArray(arguments);\n        args.unshift(source);\n        return $.validator.format.apply( this, args );\n      };\n    }\n    if ( arguments.length > 2 && params.constructor !== Array  ) {\n      params = $.makeArray(arguments).slice(1);\n    }\n    if ( params.constructor !== Array ) {\n      params = [ params ];\n    }\n    $.each(params, function( i, n ) {\n      source = source.replace( new RegExp("\\\\{" + i + "\\\\}", "g"), function() {\n        return n;\n      });\n    });\n    return source;\n  };\n\n  $.extend($.validator, {\n\n    defaults: {\n      messages: {},\n      groups: {},\n      rules: {},\n      errorClass: "error",\n      validClass: "valid",\n      errorElement: "label",\n      focusInvalid: true,\n      errorContainer: $([]),\n      errorLabelContainer: $([]),\n      onsubmit: true,\n      ignore: ":hidden",\n      ignoreTitle: false,\n      onfocusin: function( element, event ) {\n        this.lastActive = element;\n\n        // hide error label and remove error class on focus if enabled\n        if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {\n          if ( this.settings.unhighlight ) {\n            this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );\n          }\n          this.addWrapper(this.errorsFor(element)).hide();\n        }\n      },\n      onfocusout: function( element, event ) {\n        if ( !this.checkable(element) && (element.name in this.submitted || !this.optional(element)) ) {\n          this.element(element);\n        }\n      },\n      onkeyup: function( element, event ) {\n        if ( event.which === 9 && this.elementValue(element) === "" ) {\n          return;\n        } else if ( element.name in this.submitted || element === this.lastElement ) {\n          this.element(element);\n        }\n      },\n      onclick: function( element, event ) {\n        // click on selects, radiobuttons and checkboxes\n        if ( element.name in this.submitted ) {\n          this.element(element);\n        }\n        // or option elements, check parent select in that case\n        else if ( element.parentNode.name in this.submitted ) {\n          this.element(element.parentNode);\n        }\n      },\n      highlight: function( element, errorClass, validClass ) {\n        if ( element.type === "radio" ) {\n          this.findByName(element.name).addClass(errorClass).removeClass(validClass);\n        } else {\n          $(element).addClass(errorClass).removeClass(validClass);\n        }\n      },\n      unhighlight: function( element, errorClass, validClass ) {\n        if ( element.type === "radio" ) {\n          this.findByName(element.name).removeClass(errorClass).addClass(validClass);\n        } else {\n          $(element).removeClass(errorClass).addClass(validClass);\n        }\n      }\n    },\n\n    // http://docs.jquery.com/Plugins/Validation/Validator/setDefaults\n    setDefaults: function( settings ) {\n      $.extend( $.validator.defaults, settings );\n    },\n\n    messages: {\n      required: "This field is required.",\n      remote: "Please fix this field.",\n      email: "Please enter a valid email address.",\n      url: "Please enter a valid URL.",\n      date: "Please enter a valid date.",\n      dateISO: "Please enter a valid date (ISO).",\n      number: "Please enter a valid number.",\n      digits: "Please enter only digits.",\n      creditcard: "Please enter a valid credit card number.",\n      equalTo: "Please enter the same value again.",\n      maxlength: $.validator.format("Please enter no more than {0} characters."),\n      minlength: $.validator.format("Please enter at least {0} characters."),\n      rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),\n      range: $.validator.format("Please enter a value between {0} and {1}."),\n      max: $.validator.format("Please enter a value less than or equal to {0}."),\n      min: $.validator.format("Please enter a value greater than or equal to {0}.")\n    },\n\n    autoCreateRanges: false,\n\n    prototype: {\n\n      init: function() {\n        this.labelContainer = $(this.settings.errorLabelContainer);\n        this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);\n        this.containers = $(this.settings.errorContainer).add( this.settings.errorLabelContainer );\n        this.submitted = {};\n        this.valueCache = {};\n        this.pendingRequest = 0;\n        this.pending = {};\n        this.invalid = {};\n        this.reset();\n\n        var groups = (this.groups = {});\n        $.each(this.settings.groups, function( key, value ) {\n          if ( typeof value === "string" ) {\n            value = value.split(/\\s/);\n          }\n          $.each(value, function( index, name ) {\n            groups[name] = key;\n          });\n        });\n        var rules = this.settings.rules;\n        $.each(rules, function( key, value ) {\n          rules[key] = $.validator.normalizeRule(value);\n        });\n\n        function delegate(event) {\n          var validator = $.data(this[0].form, "validator"),\n            eventType = "on" + event.type.replace(/^validate/, "");\n          if ( validator.settings[eventType] ) {\n            validator.settings[eventType].call(validator, this[0], event);\n          }\n        }\n        $(this.currentForm)\n          .validateDelegate(":text, [type=\'password\'], [type=\'file\'], select, textarea, " +\n            "[type=\'number\'], [type=\'search\'] ,[type=\'tel\'], [type=\'url\'], " +\n            "[type=\'email\'], [type=\'datetime\'], [type=\'date\'], [type=\'month\'], " +\n            "[type=\'week\'], [type=\'time\'], [type=\'datetime-local\'], " +\n            "[type=\'range\'], [type=\'color\'] ",\n            "focusin focusout keyup", delegate)\n          .validateDelegate("[type=\'radio\'], [type=\'checkbox\'], select, option", "click", delegate);\n\n        if ( this.settings.invalidHandler ) {\n          $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);\n        }\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/form\n      form: function() {\n        this.checkForm();\n        $.extend(this.submitted, this.errorMap);\n        this.invalid = $.extend({}, this.errorMap);\n        if ( !this.valid() ) {\n          $(this.currentForm).triggerHandler("invalid-form", [this]);\n        }\n        this.showErrors();\n        return this.valid();\n      },\n\n      checkForm: function() {\n        this.prepareForm();\n        for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) {\n          this.check( elements[i] );\n        }\n        return this.valid();\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/element\n      element: function( element ) {\n        element = this.validationTargetFor( this.clean( element ) );\n        this.lastElement = element;\n        this.prepareElement( element );\n        this.currentElements = $(element);\n        var result = this.check( element ) !== false;\n        if ( result ) {\n          delete this.invalid[element.name];\n        } else {\n          this.invalid[element.name] = true;\n        }\n        if ( !this.numberOfInvalids() ) {\n          // Hide error containers on last error\n          this.toHide = this.toHide.add( this.containers );\n        }\n        this.showErrors();\n        return result;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/showErrors\n      showErrors: function( errors ) {\n        if ( errors ) {\n          // add items to error list and map\n          $.extend( this.errorMap, errors );\n          this.errorList = [];\n          for ( var name in errors ) {\n            this.errorList.push({\n              message: errors[name],\n              element: this.findByName(name)[0]\n            });\n          }\n          // remove items from success list\n          this.successList = $.grep( this.successList, function( element ) {\n            return !(element.name in errors);\n          });\n        }\n        if ( this.settings.showErrors ) {\n          this.settings.showErrors.call( this, this.errorMap, this.errorList );\n        } else {\n          this.defaultShowErrors();\n        }\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/resetForm\n      resetForm: function() {\n        if ( $.fn.resetForm ) {\n          $(this.currentForm).resetForm();\n        }\n        this.submitted = {};\n        this.lastElement = null;\n        this.prepareForm();\n        this.hideErrors();\n        this.elements().removeClass( this.settings.errorClass ).removeData( "previousValue" );\n      },\n\n      numberOfInvalids: function() {\n        return this.objectLength(this.invalid);\n      },\n\n      objectLength: function( obj ) {\n        var count = 0;\n        for ( var i in obj ) {\n          count++;\n        }\n        return count;\n      },\n\n      hideErrors: function() {\n        this.addWrapper( this.toHide ).hide();\n      },\n\n      valid: function() {\n        return this.size() === 0;\n      },\n\n      size: function() {\n        return this.errorList.length;\n      },\n\n      focusInvalid: function() {\n        if ( this.settings.focusInvalid ) {\n          try {\n            $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])\n              .filter(":visible")\n              .focus()\n              // manually trigger focusin event; without it, focusin handler isn\'t called, findLastActive won\'t have anything to find\n              .trigger("focusin");\n          } catch(e) {\n            // ignore IE throwing errors when focusing hidden elements\n          }\n        }\n      },\n\n      findLastActive: function() {\n        var lastActive = this.lastActive;\n        return lastActive && $.grep(this.errorList, function( n ) {\n          return n.element.name === lastActive.name;\n        }).length === 1 && lastActive;\n      },\n\n      elements: function() {\n        var validator = this,\n          rulesCache = {};\n\n        // select all valid inputs inside the form (no submit or reset buttons)\n        return $(this.currentForm)\n          .find("input, select, textarea")\n          .not(":submit, :reset, :image, [disabled]")\n          .not( this.settings.ignore )\n          .filter(function() {\n            if ( !this.name && validator.settings.debug && window.console ) {\n              console.error( "%o has no name assigned", this);\n            }\n\n            // select only the first element for each name, and only those with rules specified\n            if ( this.name in rulesCache || !validator.objectLength($(this).rules()) ) {\n              return false;\n            }\n\n            rulesCache[this.name] = true;\n            return true;\n          });\n      },\n\n      clean: function( selector ) {\n        return $(selector)[0];\n      },\n\n      errors: function() {\n        var errorClass = this.settings.errorClass.replace(" ", ".");\n        return $(this.settings.errorElement + "." + errorClass, this.errorContext);\n      },\n\n      reset: function() {\n        this.successList = [];\n        this.errorList = [];\n        this.errorMap = {};\n        this.toShow = $([]);\n        this.toHide = $([]);\n        this.currentElements = $([]);\n      },\n\n      prepareForm: function() {\n        this.reset();\n        this.toHide = this.errors().add( this.containers );\n      },\n\n      prepareElement: function( element ) {\n        this.reset();\n        this.toHide = this.errorsFor(element);\n      },\n\n      elementValue: function( element ) {\n        var type = $(element).attr("type"),\n          val = $(element).val();\n\n        if ( type === "radio" || type === "checkbox" ) {\n          return $("input[name=\'" + $(element).attr("name") + "\']:checked").val();\n        }\n\n        if ( typeof val === "string" ) {\n          return val.replace(/\\r/g, "");\n        }\n        return val;\n      },\n\n      check: function( element ) {\n        element = this.validationTargetFor( this.clean( element ) );\n\n        var rules = $(element).rules();\n        var dependencyMismatch = false;\n        var val = this.elementValue(element);\n        var result;\n\n        for (var method in rules ) {\n          var rule = { method: method, parameters: rules[method] };\n          try {\n\n            result = $.validator.methods[method].call( this, val, element, rule.parameters );\n\n            // if a method indicates that the field is optional and therefore valid,\n            // don\'t mark it as valid when there are no other rules\n            if ( result === "dependency-mismatch" ) {\n              dependencyMismatch = true;\n              continue;\n            }\n            dependencyMismatch = false;\n\n            if ( result === "pending" ) {\n              this.toHide = this.toHide.not( this.errorsFor(element) );\n              return;\n            }\n\n            if ( !result ) {\n              this.formatAndAdd( element, rule );\n              return false;\n            }\n          } catch(e) {\n            if ( this.settings.debug && window.console ) {\n              console.log( "Exception occurred when checking element " + element.id + ", check the \'" + rule.method + "\' method.", e );\n            }\n            throw e;\n          }\n        }\n        if ( dependencyMismatch ) {\n          return;\n        }\n        if ( this.objectLength(rules) ) {\n          this.successList.push(element);\n        }\n        return true;\n      },\n\n      // return the custom message for the given element and validation method\n      // specified in the element\'s HTML5 data attribute\n      customDataMessage: function( element, method ) {\n        return $(element).data("msg-" + method.toLowerCase()) || (element.attributes && $(element).attr("data-msg-" + method.toLowerCase()));\n      },\n\n      // return the custom message for the given element name and validation method\n      customMessage: function( name, method ) {\n        var m = this.settings.messages[name];\n        return m && (m.constructor === String ? m : m[method]);\n      },\n\n      // return the first defined argument, allowing empty strings\n      findDefined: function() {\n        for(var i = 0; i < arguments.length; i++) {\n          if ( arguments[i] !== undefined ) {\n            return arguments[i];\n          }\n        }\n        return undefined;\n      },\n\n      defaultMessage: function( element, method ) {\n        return this.findDefined(\n          this.customMessage( element.name, method ),\n          this.customDataMessage( element, method ),\n          // title is never undefined, so handle empty string as undefined\n          !this.settings.ignoreTitle && element.title || undefined,\n          $.validator.messages[method],\n          "<strong>Warning: No message defined for " + element.name + "</strong>"\n        );\n      },\n\n      formatAndAdd: function( element, rule ) {\n        var message = this.defaultMessage( element, rule.method ),\n          theregex = /\\$?\\{(\\d+)\\}/g;\n        if ( typeof message === "function" ) {\n          message = message.call(this, rule.parameters, element);\n        } else if (theregex.test(message)) {\n          message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);\n        }\n        this.errorList.push({\n          message: message,\n          element: element\n        });\n\n        this.errorMap[element.name] = message;\n        this.submitted[element.name] = message;\n      },\n\n      addWrapper: function( toToggle ) {\n        if ( this.settings.wrapper ) {\n          toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );\n        }\n        return toToggle;\n      },\n\n      defaultShowErrors: function() {\n        var i, elements;\n        for ( i = 0; this.errorList[i]; i++ ) {\n          var error = this.errorList[i];\n          if ( this.settings.highlight ) {\n            this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );\n          }\n          this.showLabel( error.element, error.message );\n        }\n        if ( this.errorList.length ) {\n          this.toShow = this.toShow.add( this.containers );\n        }\n        if ( this.settings.success ) {\n          for ( i = 0; this.successList[i]; i++ ) {\n            this.showLabel( this.successList[i] );\n          }\n        }\n        if ( this.settings.unhighlight ) {\n          for ( i = 0, elements = this.validElements(); elements[i]; i++ ) {\n            this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );\n          }\n        }\n        this.toHide = this.toHide.not( this.toShow );\n        this.hideErrors();\n        this.addWrapper( this.toShow ).show();\n      },\n\n      validElements: function() {\n        return this.currentElements.not(this.invalidElements());\n      },\n\n      invalidElements: function() {\n        return $(this.errorList).map(function() {\n          return this.element;\n        });\n      },\n\n      showLabel: function( element, message ) {\n        var label = this.errorsFor( element );\n        if ( label.length ) {\n          // refresh error/success class\n          label.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );\n          // replace message on existing label\n          label.html(message);\n        } else {\n          // create label\n          label = $("<" + this.settings.errorElement + ">")\n            .attr("for", this.idOrName(element))\n            .addClass(this.settings.errorClass)\n            .html(message || "");\n          if ( this.settings.wrapper ) {\n            // make sure the element is visible, even in IE\n            // actually showing the wrapped element is handled elsewhere\n            label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();\n          }\n          if ( !this.labelContainer.append(label).length ) {\n            if ( this.settings.errorPlacement ) {\n              this.settings.errorPlacement(label, $(element) );\n            } else {\n              label.insertAfter(element);\n            }\n          }\n        }\n        if ( !message && this.settings.success ) {\n          label.text("");\n          if ( typeof this.settings.success === "string" ) {\n            label.addClass( this.settings.success );\n          } else {\n            this.settings.success( label, element );\n          }\n        }\n        this.toShow = this.toShow.add(label);\n      },\n\n      errorsFor: function( element ) {\n        var name = this.idOrName(element);\n        return this.errors().filter(function() {\n          return $(this).attr("for") === name;\n        });\n      },\n\n      idOrName: function( element ) {\n        return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);\n      },\n\n      validationTargetFor: function( element ) {\n        // if radio/checkbox, validate first element in group instead\n        if ( this.checkable(element) ) {\n          element = this.findByName( element.name ).not(this.settings.ignore)[0];\n        }\n        return element;\n      },\n\n      checkable: function( element ) {\n        return (/radio|checkbox/i).test(element.type);\n      },\n\n      findByName: function( name ) {\n        return $(this.currentForm).find("[name=\'" + name + "\']");\n      },\n\n      getLength: function( value, element ) {\n        switch( element.nodeName.toLowerCase() ) {\n          case "select":\n            return $("option:selected", element).length;\n          case "input":\n            if ( this.checkable( element) ) {\n              return this.findByName(element.name).filter(":checked").length;\n            }\n        }\n        return value.length;\n      },\n\n      depend: function( param, element ) {\n        return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;\n      },\n\n      dependTypes: {\n        "boolean": function( param, element ) {\n          return param;\n        },\n        "string": function( param, element ) {\n          return !!$(param, element.form).length;\n        },\n        "function": function( param, element ) {\n          return param(element);\n        }\n      },\n\n      optional: function( element ) {\n        var val = this.elementValue(element);\n        return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";\n      },\n\n      startRequest: function( element ) {\n        if ( !this.pending[element.name] ) {\n          this.pendingRequest++;\n          this.pending[element.name] = true;\n        }\n      },\n\n      stopRequest: function( element, valid ) {\n        this.pendingRequest--;\n        // sometimes synchronization fails, make sure pendingRequest is never < 0\n        if ( this.pendingRequest < 0 ) {\n          this.pendingRequest = 0;\n        }\n        delete this.pending[element.name];\n        if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {\n          $(this.currentForm).submit();\n          this.formSubmitted = false;\n        } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {\n          $(this.currentForm).triggerHandler("invalid-form", [this]);\n          this.formSubmitted = false;\n        }\n      },\n\n      previousValue: function( element ) {\n        return $.data(element, "previousValue") || $.data(element, "previousValue", {\n          old: null,\n          valid: true,\n          message: this.defaultMessage( element, "remote" )\n        });\n      }\n\n    },\n\n    classRuleSettings: {\n      required: {required: true},\n      email: {email: true},\n      url: {url: true},\n      date: {date: true},\n      dateISO: {dateISO: true},\n      number: {number: true},\n      digits: {digits: true},\n      creditcard: {creditcard: true}\n    },\n\n    addClassRules: function( className, rules ) {\n      if ( className.constructor === String ) {\n        this.classRuleSettings[className] = rules;\n      } else {\n        $.extend(this.classRuleSettings, className);\n      }\n    },\n\n    classRules: function( element ) {\n      var rules = {};\n      var classes = $(element).attr("class");\n      if ( classes ) {\n        $.each(classes.split(" "), function() {\n          if ( this in $.validator.classRuleSettings ) {\n            $.extend(rules, $.validator.classRuleSettings[this]);\n          }\n        });\n      }\n      return rules;\n    },\n\n    attributeRules: function( element ) {\n      var rules = {};\n      var $element = $(element);\n      var type = $element[0].getAttribute("type");\n\n      for (var method in $.validator.methods) {\n        var value;\n\n        // support for <input required> in both html5 and older browsers\n        if ( method === "required" ) {\n          value = $element.get(0).getAttribute(method);\n          // Some browsers return an empty string for the required attribute\n          // and non-HTML5 browsers might have required="" markup\n          if ( value === "" ) {\n            value = true;\n          }\n          // force non-HTML5 browsers to return bool\n          value = !!value;\n        } else {\n          value = $element.attr(method);\n        }\n\n        // convert the value to a number for number inputs, and for text for backwards compability\n        // allows type="date" and others to be compared as strings\n        if ( /min|max/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {\n          value = Number(value);\n        }\n\n        if ( value ) {\n          rules[method] = value;\n        } else if ( type === method && type !== \'range\' ) {\n          // exception: the jquery validate \'range\' method\n          // does not test for the html5 \'range\' type\n          rules[method] = true;\n        }\n      }\n\n      // maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs\n      if ( rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength) ) {\n        delete rules.maxlength;\n      }\n\n      return rules;\n    },\n\n    dataRules: function( element ) {\n      var method, value,\n        rules = {}, $element = $(element);\n      for (method in $.validator.methods) {\n        value = $element.data("rule-" + method.toLowerCase());\n        if ( value !== undefined ) {\n          rules[method] = value;\n        }\n      }\n      return rules;\n    },\n\n    staticRules: function( element ) {\n      var rules = {};\n      var validator = $.data(element.form, "validator");\n      if ( validator.settings.rules ) {\n        rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};\n      }\n      return rules;\n    },\n\n    normalizeRules: function( rules, element ) {\n      // handle dependency check\n      $.each(rules, function( prop, val ) {\n        // ignore rule when param is explicitly false, eg. required:false\n        if ( val === false ) {\n          delete rules[prop];\n          return;\n        }\n        if ( val.param || val.depends ) {\n          var keepRule = true;\n          switch (typeof val.depends) {\n            case "string":\n              keepRule = !!$(val.depends, element.form).length;\n              break;\n            case "function":\n              keepRule = val.depends.call(element, element);\n              break;\n          }\n          if ( keepRule ) {\n            rules[prop] = val.param !== undefined ? val.param : true;\n          } else {\n            delete rules[prop];\n          }\n        }\n      });\n\n      // evaluate parameters\n      $.each(rules, function( rule, parameter ) {\n        rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;\n      });\n\n      // clean number parameters\n      $.each([\'minlength\', \'maxlength\'], function() {\n        if ( rules[this] ) {\n          rules[this] = Number(rules[this]);\n        }\n      });\n      $.each([\'rangelength\', \'range\'], function() {\n        var parts;\n        if ( rules[this] ) {\n          if ( $.isArray(rules[this]) ) {\n            rules[this] = [Number(rules[this][0]), Number(rules[this][1])];\n          } else if ( typeof rules[this] === "string" ) {\n            parts = rules[this].split(/[\\s,]+/);\n            rules[this] = [Number(parts[0]), Number(parts[1])];\n          }\n        }\n      });\n\n      if ( $.validator.autoCreateRanges ) {\n        // auto-create ranges\n        if ( rules.min && rules.max ) {\n          rules.range = [rules.min, rules.max];\n          delete rules.min;\n          delete rules.max;\n        }\n        if ( rules.minlength && rules.maxlength ) {\n          rules.rangelength = [rules.minlength, rules.maxlength];\n          delete rules.minlength;\n          delete rules.maxlength;\n        }\n      }\n\n      return rules;\n    },\n\n    // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}\n    normalizeRule: function( data ) {\n      if ( typeof data === "string" ) {\n        var transformed = {};\n        $.each(data.split(/\\s/), function() {\n          transformed[this] = true;\n        });\n        data = transformed;\n      }\n      return data;\n    },\n\n    // http://docs.jquery.com/Plugins/Validation/Validator/addMethod\n    addMethod: function( name, method, message ) {\n      $.validator.methods[name] = method;\n      $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];\n      if ( method.length < 3 ) {\n        $.validator.addClassRules(name, $.validator.normalizeRule(name));\n      }\n    },\n\n    methods: {\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/required\n      required: function( value, element, param ) {\n        // check if dependency is met\n        if ( !this.depend(param, element) ) {\n          return "dependency-mismatch";\n        }\n        if ( element.nodeName.toLowerCase() === "select" ) {\n          // could be an array for select-multiple or a string, both are fine this way\n          var val = $(element).val();\n          return val && val.length > 0;\n        }\n        if ( this.checkable(element) ) {\n          return this.getLength(value, element) > 0;\n        }\n        return $.trim(value).length > 0;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/email\n      email: function( value, element ) {\n        // contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/\n        return this.optional(element) || /^((([a-z]|\\d|[!#\\$%&\'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&\'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/url\n      url: function( value, element ) {\n        // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/\n        return this.optional(element) || /^(https?|s?ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/date\n      date: function( value, element ) {\n        return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/dateISO\n      dateISO: function( value, element ) {\n        return this.optional(element) || /^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/number\n      number: function( value, element ) {\n        return this.optional(element) || /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/digits\n      digits: function( value, element ) {\n        return this.optional(element) || /^\\d+$/.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/creditcard\n      // based on http://en.wikipedia.org/wiki/Luhn\n      creditcard: function( value, element ) {\n        if ( this.optional(element) ) {\n          return "dependency-mismatch";\n        }\n        // accept only spaces, digits and dashes\n        if ( /[^0-9 \\-]+/.test(value) ) {\n          return false;\n        }\n        var nCheck = 0,\n          nDigit = 0,\n          bEven = false;\n\n        value = value.replace(/\\D/g, "");\n\n        for (var n = value.length - 1; n >= 0; n--) {\n          var cDigit = value.charAt(n);\n          nDigit = parseInt(cDigit, 10);\n          if ( bEven ) {\n            if ( (nDigit *= 2) > 9 ) {\n              nDigit -= 9;\n            }\n          }\n          nCheck += nDigit;\n          bEven = !bEven;\n        }\n\n        return (nCheck % 10) === 0;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/minlength\n      minlength: function( value, element, param ) {\n        var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);\n        return this.optional(element) || length >= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/maxlength\n      maxlength: function( value, element, param ) {\n        var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);\n        return this.optional(element) || length <= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/rangelength\n      rangelength: function( value, element, param ) {\n        var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);\n        return this.optional(element) || ( length >= param[0] && length <= param[1] );\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/min\n      min: function( value, element, param ) {\n        return this.optional(element) || value >= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/max\n      max: function( value, element, param ) {\n        return this.optional(element) || value <= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/range\n      range: function( value, element, param ) {\n        return this.optional(element) || ( value >= param[0] && value <= param[1] );\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/equalTo\n      equalTo: function( value, element, param ) {\n        // bind to the blur event of the target in order to revalidate whenever the target field is updated\n        // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead\n        var target = $(param);\n        if ( this.settings.onfocusout ) {\n          target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {\n            $(element).valid();\n          });\n        }\n        return value === target.val();\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/remote\n      remote: function( value, element, param ) {\n        if ( this.optional(element) ) {\n          return "dependency-mismatch";\n        }\n\n        var previous = this.previousValue(element);\n        if (!this.settings.messages[element.name] ) {\n          this.settings.messages[element.name] = {};\n        }\n        previous.originalMessage = this.settings.messages[element.name].remote;\n        this.settings.messages[element.name].remote = previous.message;\n\n        param = typeof param === "string" && {url:param} || param;\n\n        if ( previous.old === value ) {\n          return previous.valid;\n        }\n\n        previous.old = value;\n        var validator = this;\n        this.startRequest(element);\n        var data = {};\n        data[element.name] = value;\n        $.ajax($.extend(true, {\n          url: param,\n          mode: "abort",\n          port: "validate" + element.name,\n          dataType: "json",\n          data: data,\n          success: function( response ) {\n            validator.settings.messages[element.name].remote = previous.originalMessage;\n            var valid = response === true || response === "true";\n            if ( valid ) {\n              var submitted = validator.formSubmitted;\n              validator.prepareElement(element);\n              validator.formSubmitted = submitted;\n              validator.successList.push(element);\n              delete validator.invalid[element.name];\n              validator.showErrors();\n            } else {\n              var errors = {};\n              var message = response || validator.defaultMessage( element, "remote" );\n              errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;\n              validator.invalid[element.name] = true;\n              validator.showErrors(errors);\n            }\n            previous.valid = valid;\n            validator.stopRequest(element, valid);\n          }\n        }, param));\n        return "pending";\n      }\n\n    }\n\n  });\n\n// deprecated, use $.validator.format instead\n  $.format = $.validator.format;\n\n}(jQuery));\n\n// ajax mode: abort\n// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});\n// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()\n(function($) {\n  var pendingRequests = {};\n  // Use a prefilter if available (1.5+)\n  if ( $.ajaxPrefilter ) {\n    $.ajaxPrefilter(function( settings, _, xhr ) {\n      var port = settings.port;\n      if ( settings.mode === "abort" ) {\n        if ( pendingRequests[port] ) {\n          pendingRequests[port].abort();\n        }\n        pendingRequests[port] = xhr;\n      }\n    });\n  } else {\n    // Proxy ajax\n    var ajax = $.ajax;\n    $.ajax = function( settings ) {\n      var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,\n        port = ( "port" in settings ? settings : $.ajaxSettings ).port;\n      if ( mode === "abort" ) {\n        if ( pendingRequests[port] ) {\n          pendingRequests[port].abort();\n        }\n        pendingRequests[port] = ajax.apply(this, arguments);\n        return pendingRequests[port];\n      }\n      return ajax.apply(this, arguments);\n    };\n  }\n}(jQuery));\n\n// provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation\n// handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target\n(function($) {\n  $.extend($.fn, {\n    validateDelegate: function( delegate, type, handler ) {\n      return this.bind(type, function( event ) {\n        var target = $(event.target);\n        if ( target.is(delegate) ) {\n          return handler.apply(target, arguments);\n        }\n      });\n    }\n  });\n}(jQuery));\n'},310:function(n,e,t){"use strict";t(0)(t(311))},311:function(n,e){n.exports="spweb.Form = (function($, utils, config) {\n\n /**\n  * Binds javascript behaviors to an html form\n  * @requires jQuery\n  * @requires spweb.utils\n  * @requires spweb.config\n  *\n  */\n\n  'use strict';\n\n  /**\n   * @constructor\n   * @param {Object} form jQuery object corresponding to an html form element\n   */\n  function Form(form) {\n    this.form = form;\n\n    /**\n     * @private\n     * Keep track of form submission state\n     */\n    this._isSubmitting = false;\n  }\n\n  /**\n   * Attaches the jQuery validation plugin to the form\n   * @param {Object} [options] Options to pass to the validation plugin. Merges with, and potentially\n   *    overrides, the default settings we have chosen for form validation.\n   */\n  Form.prototype.init = function(options) {\n    var self = this,\n      validationOptions = {\n        submitHandler: function() {\n          var form = self.form;\n          if(!self._isSubmitting) {\n            self._isSubmitting = true;\n            self.showAjaxSpinner();\n\n            $.publish('form_submit.' + self.form.attr('id'));\n            jQuery.ajax({\n              data: form.serialize(),\n              dataType: 'json',\n              success: function(data) {\n                $.publish('form_success.' + self.form.attr('id'), data);\n                // Must reset the recapture or it won't be able to post again.\n                self._resetCaptcha();\n              },\n              error: function() {\n                $.publish('form_error.' + self.form.attr('id'));\n                // Must reset the recapture or it won't be able to post again.\n                self._resetCaptcha();\n              },\n              complete: function() {\n                self.hideAjaxSpinner();\n                self._isSubmitting = false;\n              },\n              type: form.attr('method'),\n              url: form.attr('action')\n            });\n          }\n        },\n        errorClass: 'has-error',\n\n        errorPlacement: function(error, element) {\n          //sp-bootstrap pattern\n          var formGroup = element.parents('.form-group');\n          if (formGroup.length > 0) {\n            formGroup.addClass('has-error');\n            error.addClass('control-label-validation');\n          }\n\n          element.after(error);\n        },\n\n        success: function(label) {\n          //sp-bootstrap pattern\n          var formGroup = label.parents('.form-group');\n          if (formGroup.length > 0) {\n            // Remove all error labels\n            formGroup.removeClass('has-error');\n            \n            // We must remove the has-error class on the children too. This \n            // fixes https://ghe.spotify.net/morpheus/website/pull/4558#issuecomment-1033304\n            formGroup.children('.has-error').removeClass('has-error');\n            \n            label.remove();\n          }\n        }\n      };\n\n    this.validationOptions = jQuery.extend(validationOptions, options);\n    this._setupCaptcha();\n    this._setupValidation();\n\n    if (this.validationOptions.submitHandler !== null) {\n      this._insertAjaxSpinner();\n    }\n  };\n  \n  Form.prototype.scrollToFirstError = function() {\n\n    var errorTops = [];\n\n    var e = this.form.find('.js-general-error');\n    if (!e.hasClass(\"hidden\")) {\n      errorTops.push(e.offset().top);\n    }\n\n    if (this.validator) {\n      $.each(this.validator.errorList, function (i, val) {\n        if (val.element) {\n          errorTops.push($(val.element).offset().top);\n        }\n      });\n    }\n\n    if (errorTops.length === 0) {\n      return;\n    }\n\n    var isOffsetVisible = function (offset) {\n      var viewportHeight = $(window).height(),\n        documentScrollTop = $(document).scrollTop();\n      return offset > documentScrollTop && offset < (documentScrollTop + viewportHeight);\n    };\n\n    var scrollDestination = Math.min.apply(null, errorTops); // minimum value from the array. \n\n    // Don't scroll if the element is already visible\n    if (isOffsetVisible(scrollDestination)) {\n      return;\n    }\n\n    $('html,body').animate({\n      scrollTop: scrollDestination\n    }, 500);\n\n  };\n\n  /**\n   * Implicitly called by the init method, this does the actual calling of the validation plugin.\n   * @private\n   */\n  Form.prototype._setupValidation = function() {\n    this.validator = this.form.validate(this.validationOptions);\n  };\n\n  /**\n   * Resets the form\n   */\n  Form.prototype.resetForm = function() {\n    this.validator.resetForm();\n  };\n\n  /**\n   * Prepends ajax spinner element to this.form\n   * @private\n   */\n  Form.prototype._insertAjaxSpinner = function() {\n    var spinner = jQuery('<div></div>');\n\n    spinner.addClass('hidden ajax-spinner');\n\n    this.form.prepend(spinner);\n    this.ajaxSpinner = spinner;\n  };\n\n  /**\n   * Shows ajax spinner animated GIF.\n   */\n  Form.prototype.showAjaxSpinner = function() {\n    this.ajaxSpinner.removeClass('hidden');\n  };\n\n  /**\n   * Hides ajax spinner animated GIF.\n   */\n  Form.prototype.hideAjaxSpinner = function() {\n    this.ajaxSpinner.addClass('hidden');\n  };\n\n  /**\n   * This is a default showGeneralError. If it finds an element with class=\"js-general-error\" and data-error=\"...\",\n   * it will show this error. Calling this function with a string parameter shows the error with that message.\n   * @param {String} message\n   */\n  Form.prototype.showGeneralError = function(message) {\n    var e = this.form.find('.js-general-error');\n    if(e.length && (message || e.data('error'))) {\n      e.html(message ? message : e.data('error')).removeClass('hidden');\n    }\n    this.scrollToFirstError();\n  };\n\n  /**\n   * This is a default hideGeneralError. If it finds an element with class=\"js-general-error\" it will hide it.\n   */\n  Form.prototype.hideGeneralError = function() {\n    var e = this.form.find('.js-general-error');\n    if(e.length) {\n      e.addClass('hidden');\n    }\n  };\n\n  Form.prototype._resetCaptcha = function() {\n    // We should reset the recapture after every ajax post because or the\n    // captcha will fail on a second post.\n    if (document.getElementById(\"captcha-div\") !== null) {\n      grecaptcha.reset();\n    }\n  };\n\n  Form.prototype._setupCaptcha = function() {\n    var div = document.getElementById(\"captcha-div\");\n    if (div === null) {\n      return;\n    }\n\n    var _this = this;\n    window.captchaSuccessCallback = function (response) {\n      // This initiates validation on the hidden form element when the captcha succeeds.\n      // This ensures the validation error is cleared as soon as the captcha is passed.\n      _this.validator.element(\"#captcha-hidden\");\n    };\n\n    // This configures validation on the captcha hidden form element.\n    this.validationOptions = this.validationOptions || {};\n    this.validationOptions.ignore = '.ignore';\n    this.validationOptions.messages = this.validationOptions.messages || {};\n    this.validationOptions.rules = this.validationOptions.rules || {};\n\n    $.extend(this.validationOptions.messages, {\n      captcha_hidden: {\n        required: div.getAttribute(\"data-error\")\n      }\n    });\n\n    $.extend(this.validationOptions.rules, {\n      captcha_hidden: {\n        required: function () {\n          return grecaptcha.getResponse() === \"\";\n        }\n      }\n    });\n  };\n\n  return Form;\n\n}(jQuery, spweb.utils, spweb.config));\n"},312:function(n,e,t){"use strict";t(0)(t(313))},313:function(n,e){n.exports="(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n  (function() {\n    /**\n     * @file\n     * Introduces a function called \"defer\" that allows functions to be\n     * executed in the next available tick.\n     *\n     * Unlike \"setTimeout\", \"defer\" executes the function at the nearest\n     * possible time without clamping.\n     *\n     * @see Spotify.defer\n     */\n    'use strict';\n\n    var hasWindow = typeof window != 'undefined';\n    var hasDefineProperty = typeof Object.defineProperty == 'function';\n\n    if (hasWindow && window.__modDefFn) {\n      // If deferred has been attached to the global scope\n      module.exports = window.__modDefFn;\n      return;\n    }\n\n    /**\n     * Storage for deferred functions to be executed.\n     *\n     * @type {Array.<function()>}\n     * @private\n     */\n    var deferred = [];\n\n\n    /**\n     * A bound version of the postMessage routine used to trigger deferred\n     * execution.\n     *\n     * @type {function()}\n     * @private\n     */\n    var send;\n    var origin;\n\n    if (hasWindow && window.postMessage) {\n      origin = (window.location.origin ||\n        window.location.protocol + '//' + window.location.hostname);\n      send = window.postMessage.bind(window, '@execute_deferreds', origin);\n      if (!window.__hasDeferredHandler) {\n        if (hasDefineProperty) {\n          Object.defineProperty(window, '__hasDeferredHandler', {value: 1});\n        } else {\n          window.__hasDeferredHandler = 1;\n        }\n        var handler = function(e) {\n          if (e.origin != origin && e.data != '@execute_deferreds') {\n            return;\n          }\n          executeDeferreds();\n        };\n        if (window.addEventListener) {\n          window.addEventListener('message', handler);\n        } else {\n          window.attachEvent('onmessage', handler);\n        }\n      }\n    } else if (typeof setImmediate != 'undefined') {\n      send = setImmediate.bind(null, executeDeferreds);\n    } else {\n      send = setTimeout.bind(null, executeDeferreds, 10);\n    }\n\n\n    /**\n     * Executes the deferred functions when the window\n     * receives an 'execute_deferreds' message.\n     *\n     * @private\n     */\n    function executeDeferreds() {\n      var fns = deferred.splice(0);\n      if (!fns.length) return;\n      for (var i = 0, l = fns.length; i < l; i++) {\n        try {\n          fns[i]();\n        } finally {\n          // Do nothing.\n          null;\n        }\n      }\n    }\n\n\n    /**\n     * Executes the function applied at the nearest possible time without\n     * clamping.\n     *\n     * @param {function()} fn The function to execute.\n     */\n    var defer = function(fn) {\n      var trigger = !deferred.length;\n      deferred.push(fn);\n      if (trigger) send();\n    };\n\n    if (hasWindow && !window.__modDefFn) {\n      if (hasDefineProperty) {\n        Object.defineProperty(window, '__modDefFn', {value: defer});\n      } else {\n        window.__modDefFn = defer;\n      }\n    }\n\n    /**\n     * Export public interface\n     */\n    module.exports = defer;\n\n  })();\n\n},{}],2:[function(require,module,exports){\n  /**\n   * @module spotify-eventemitter\n   */\n  'use strict';\n\n  /**\n   * @private\n   */\n  var _defer = require('spotify-deferred');\n\n  /**\n   * The event handlers.\n   *\n   * @typedef {Array.<function>}\n   * @private\n   */\n  var EventHandlers;\n\n  /**\n   * Represents an Event.\n   *\n   * **NOTE**: The Event class is an internal class: you cannot instantiate it\n   * directly. Instead, you should use the provided\n   * {@link module:spotify-eventemitter.createEvent} function.\n   *\n   * @constructor\n   * @param {string} type The type name of the event object.\n   * @param {Object} props An object that will be added as properties of the\n   *     event object.\n   * @see {@link module:spotify-eventemitter.createEvent}\n   */\n  function Event(type, props) {\n    /**\n     * The type of the event.\n     *\n     * @type {string}\n     */\n    this.type = type;\n\n    /**\n     * A flag for whether preventDefault was called.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._prevented = false;\n\n    /**\n     * A flag for whether stopPropagation was called\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._stopped = false;\n\n    /**\n     * A flag for whether stopImmediatePropagation was called.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._immediateStopped = false;\n\n    if (props) {\n      for (var key in props) {\n        if (key == 'type') {\n          continue;\n        }\n        this[key] = props[key];\n      }\n    }\n  }\n\n  /**\n   * Prevents the default operation for the event.\n   */\n  Event.prototype.preventDefault = function() {\n    this._prevented = true;\n  };\n\n  /**\n   * Returns whether preventDefault was called on the event.\n   *\n   * @return {boolean} True if preventDefault was called, false otherwise.\n   */\n  Event.prototype.isDefaultPrevented = function() {\n    return this._prevented;\n  };\n\n  /**\n   * Stops the propagation of the event.\n   */\n  Event.prototype.stopPropagation = function() {\n    this._stopped = true;\n  };\n\n  /**\n   * Returns whether stopPropagation was called on the event.\n   *\n   * @return {boolean} True if stopPropagation was called, false otherwise.\n   */\n  Event.prototype.isPropagationStopped = function() {\n    return this._stopped;\n  };\n\n  /**\n   * Stops the immediate propagation of the event.\n   *\n   * Handlers added after any event handler calling this method will not receive\n   * the event.\n   */\n  Event.prototype.stopImmediatePropagation = function() {\n    this._immediateStopped = true;\n  };\n\n  /**\n   * Returns whether stopImmediatePropagation was called on the event.\n   *\n   * @return {boolean} True if stopImmediatePropagation was called, false\n   *     otherwise.\n   */\n  Event.prototype.isImmediatePropagationStopped = function() {\n    return this._immediateStopped;\n  };\n\n  /**\n   * An EventEmitter is an object that can be listened to for events.\n   *\n   * Instances of this class are not usually used directly; instead, a class that\n   * needs EventEmitter functionality would inherit from the EventEmitter class\n   * so that it's instances can use events.\n   *\n   * @constructor\n   * @alias module:spotify-eventemitter\n   *\n   * @example <caption>Direct usage</caption>\n   * var EventEmitter = require('spotify-eventemitter');\n   * var emitter = new EventEmitter();\n   * emitter.addListener('someEvent', function() {\n *     console.log('someEvent fired!');\n * });\n   * emitter.emit('someEvent');\n   * @example <caption>Inheritance</caption>\n   * var EventEmitter = require('spotify-eventemitter');\n   * var inherit = require('spotify-inherit/inherit');\n   *\n   * function MyClass() {\n *   EventEmitter.call(this);\n * }\n   * inherit(MyClass, EventEmitter);\n   *\n   * var instance = new MyClass();\n   * instance.addListener('someEvent', function() {\n *     console.log('someEvent fired!');\n * });\n   * instance.emit('someEvent');\n   */\n  function EventEmitter() {\n    /**\n     * A map of event names to event handlers.\n     *\n     * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}\n     * @private\n     */\n    this._listenerMap;\n  }\n\n  /**\n   * Creates a new Event object.\n   *\n   * @param {string} type The type name of the event.\n   * @param {Object=} opt_params An object containing properties for the new event\n   *     object.\n   * @return {module:spotify-eventemitter~Event} The new event object.\n   */\n  EventEmitter.createEvent = function(type, opt_params) {\n    return new Event(type, opt_params);\n  };\n\n  /**\n   * Adds an event listener to the emitter.\n   *\n   * This method is idempotent: calling it multiple times using the same type\n   * and listener arguments will only set the listener once. This behaviour is\n   * done to prevent accidental additions of the same event listener.\n   *\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.addListener = function(type, listener) {\n    var _listenerMap = this._listenerMap || (this._listenerMap = {});\n    var listeners = _listenerMap[type] || (_listenerMap[type] = []);\n    if (listeners.indexOf(listener) != -1) {\n      // Handler already added, return quickly.\n      return this;\n    }\n    listeners.push(listener);\n    return this;\n  };\n\n  /**\n   * Adds multiple event listeners to the emitter.\n   *\n   * @param {Object.<string, function>} eventListeners An object, the keys of\n   *     which correspond to the name of events to listen to, and the value of\n   *     each of these keys should be a function that would be added as the\n   *     listener for that event.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.addListeners = function(eventListeners) {\n    for (var type in eventListeners) {\n      this.addListener(type, eventListeners[type]);\n    }\n    return this;\n  };\n\n  /**\n   * Adds a \"once\" event listener to the emitter, which will be removed right\n   * after it has been fired.\n   *\n   * In order to achieve the \"once\" behaviour, the listener argument passed to\n   * this method is wrapped in a function, which is then returned by the method.\n   *\n   * Because of this wrapping, this method is not idempotent: calling it multiple\n   * times with the same type and listener arguments will result to multiple\n   * event listeners attached.\n   *\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type and then automatically removed.\n   * @return {function} The function used to wrap the listener function argument.\n   *     This function can be used as an argument to removeEvent.\n   */\n  EventEmitter.prototype.addOnceListener = function(type, listener) {\n    var wrapper = function() {\n      this.removeListener(type, wrapper);\n      return listener.apply(this, arguments);\n    };\n    this.addListener(type, wrapper);\n    return wrapper;\n  };\n\n  /**\n   * Removes an event listener from the emitter.\n   *\n   * @param {string} type The type of event to remove.\n   * @param {function} listener The listener function to remove. This must be a\n   *     function that was added previously using addEvent.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.removeListener = function(type, listener) {\n    var _listenerMap = this._listenerMap;\n    var listeners = _listenerMap && _listenerMap[type];\n    if (!listeners) {\n      return this;\n    }\n    var index = listeners.indexOf(listener);\n    if (index == -1) {\n      return this;\n    }\n    listeners.splice(index, 1);\n    if (!listeners.length) {\n      _listenerMap[type] = null;\n    }\n    return this;\n  };\n\n  /**\n   * Removes all event listeners from the emitter for a particular type.\n   *\n   * @param {string} type The event type to remove.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    var _listenerMap = this._listenerMap;\n    if (!_listenerMap) {\n      return this;\n    }\n    _listenerMap[type] = null;\n    return this;\n  };\n\n  /**\n   * Removes multiple event listeners from the emitter.\n   *\n   * @param {Object.<string, function>} eventListeners An object, the keys of\n   *     which correspond to the name of events to listen to, and the value of\n   *     each of these keys should be a function that would be added as the\n   *     listener for that event.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.removeListeners = function(eventListeners) {\n    for (var type in eventListeners) {\n      this.removeListener(type, eventListeners[type]);\n    }\n    return this;\n  };\n\n  /**\n   * Creates and emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` provided in\n   * the order they were added, passing in a new Event object created using the\n   * provided `type` and `opt_params` arguments.\n   *\n   * This method emits events asynchronously: the listeners are not called until\n   * the next run loop.\n   *\n   * @param {string} type The type name of the event to emit.\n   * @param {Object=} opt_params An object containing parameters for the Event\n   *     object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was\n   *     created.\n   */\n  EventEmitter.prototype.emit = function(type, opt_params) {\n    var event = new Event(type, opt_params);\n    _defer(function() {\n      this.emitEventSync(event);\n    }.bind(this));\n    return event;\n  };\n\n  /**\n   * Emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` of the\n   * `event` provided in the order they were added, passing in the `event` as an\n   * argument.\n   *\n   * This method emits events asynchronously: the listeners are not called until\n   * the next run loop.\n   *\n   * @param {module:spotify-eventemitter~Event} event The Event object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was passed.\n   */\n  EventEmitter.prototype.emitEvent = function(event) {\n    _defer(function() {\n      this.emitEventSync(event);\n    }.bind(this));\n    return event;\n  };\n\n  /**\n   * Creates and synchronously emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` provided in\n   * the order they were added, passing in a new Event object created using the\n   * provided `type` and `opt_params` arguments.\n   *\n   * @param {string} type The type name of event to emit.\n   * @param {Object=} opt_params An object containing parameters for the event\n   *     object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was\n   *     created.\n   */\n  EventEmitter.prototype.emitSync = function(type, opt_params) {\n    var event = new Event(type, opt_params);\n    this.emitEventSync(event);\n    return event;\n  };\n\n  /**\n   * Synchronously emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` of the\n   * `event` provided in the order they were added, passing in the `event` as an\n   * argument.\n   *\n   * @param {module:spotify-eventemitter~Event} event The Event object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was passed.\n   */\n  EventEmitter.prototype.emitEventSync = function(event) {\n    var type = event.type;\n    var _listenerMap = this._listenerMap;\n    var listeners = _listenerMap && _listenerMap[type];\n    if (!listeners || !listeners.length) {\n      return event;\n    }\n    listeners = listeners.slice(0);\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].call(this, event);\n      if (event.isImmediatePropagationStopped()) {\n        break;\n      }\n    }\n    return event;\n  };\n\n// DEPRECATED METHODS:\n\n  /**\n   * Adds an event listener to the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addListener}.\n   *\n   * This method is idempotent: calling it multiple times using the same type\n   * and listener arguments will only set the listener once. This behaviour is\n   * done to prevent accidental additions of the same event listener.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#addListener}\n   */\n  EventEmitter.prototype.addEvent = function(type, listener) {\n    return this.addListener(type, listener);\n  };\n\n  /**\n   * Adds multiple event listeners to the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addListeners}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {Object.<string, function>} eventListeners An object, the keys of\n   *     which correspond to the name of events to listen to, and the value of\n   *     each of these keys should be a function that would be added as the\n   *     listener for that event.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#addListeners}\n   */\n  EventEmitter.prototype.addEvents = function(eventListeners) {\n    return this.addListeners(eventListeners);\n  };\n\n  /**\n   * Adds a \"once\" event listener to the emitter, which will be removed right\n   * after it has been fired.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addOnceListener}.\n   *\n   * In order to achieve the \"once\" behaviour, the listener argument passed to\n   * this method is wrapped in a function, which is then returned by the method.\n   *\n   * Because of this wrapping, this method is not idempotent: calling it multiple\n   * times with the same type and listener arguments will result to multiple\n   * event listeners attached.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type and then automatically removed.\n   * @return {function} The function used to wrap the listener function argument.\n   *     This function can be used as an argument to removeEvent.\n   * @see {@link module:spotify-eventemitter#addOnceListener}\n   */\n  EventEmitter.prototype.addOnceEvent = function(type, listener) {\n    return this.addOnceListener(type, listener);\n  };\n\n  /**\n   * Removes an event listener from the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#removeListener}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to remove.\n   * @param {function} listener The listener function to remove. This must be a\n   *     function that was added previously using addEvent.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#removeListener}\n   */\n  EventEmitter.prototype.removeEvent = function(type, listener) {\n    return this.removeListener(type, listener);\n  };\n\n  /**\n   * Removes multiple event listeners from the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#removeListeners}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {Object.<string, function>} events An object, the keys of which\n   *     correspond to the name of events to remove, and the value of each of\n   *     these keys should be a function that would be removed as a listener.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#removeListeners}\n   */\n  EventEmitter.prototype.removeEvents = function(eventListeners) {\n    return this.removeListeners(eventListeners);\n  };\n\n  /**\n   * Fires an event on the emitter, optionally passing arguments to the listeners.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#emit}.\n   *\n   * This method fire events asynchronously: the listeners are not called until\n   * the next run loop. A third boolean parameter can be passed to change this\n   * behaviour.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to fire.\n   * @param {Array.<*>=} opt_args A set of objects that would be passed to the\n   *     event listeners as arguments.\n   * @param {boolean=} opt_priority Passing true will fire the event synchronously.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#emit}\n   */\n  EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {\n    if (opt_priority) {\n      this.fireEventSync(type, opt_args);\n    } else {\n      var self = this;\n      _defer(function() { self.fireEventSync(type, opt_args); });\n    }\n    return this;\n  };\n\n  /**\n   * Fires an event on the emitter synchronously, optionally passing arguments to\n   * the listeners.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#emitSync}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to fire.\n   * @param {Array.<*>=} opt_args A set of objects that would be passed to the\n   *     event listeners as arguments.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#emitSync}\n   */\n  EventEmitter.prototype.fireEventSync = function(type, opt_args) {\n    var self = this;\n    var events = this._listenerMap && this._listenerMap[type];\n    if (!events || !events.length) return this;\n    events = events.slice(0);\n    var i, l;\n    if (!opt_args) {\n      for (i = 0, l = events.length; i < l; i++) {\n        events[i].call(self);\n      }\n    } else {\n      if (!Array.isArray(opt_args)) {\n        opt_args = [opt_args];\n      }\n      for (i = 0, l = events.length; i < l; i++) {\n        events[i].apply(self, opt_args);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Adds an event listener to the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addListener}.\n   *\n   * This method is idempotent: calling it multiple times using the same type\n   * and listener arguments will only set the listener once. This behaviour is\n   * done to prevent accidental additions of the same event listener.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#addListener}\n   */\n  EventEmitter.prototype.on = function(type, listener) {\n    return this.addEvent(type, listener);\n  };\n\n  /**\n   * Adds a \"once\" event listener to the emitter, which will be removed right\n   * after it has been fired.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addOnceListener}.\n   *\n   * In order to achieve the \"once\" behaviour, the listener argument passed to\n   * this method is wrapped in a function, which is then returned by the method.\n   *\n   * Because of this wrapping, this method is not idempotent: calling it multiple\n   * times with the same type and listener arguments will result to multiple\n   * event listeners attached.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type and then automatically removed.\n   * @return {function} The function used to wrap the listener function argument.\n   *     This function can be used as an argument to removeEvent.\n   * @see {@link module:spotify-eventemitter#addOnceListener}\n   */\n  EventEmitter.prototype.once = function(type, listener) {\n    return this.addOnceEvent(type, listener);\n  };\n\n  /**\n   * Removes an event listener or all event listeners from the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#removeListener}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to remove.\n   * @param {function=} opt_listener The listener function to remove. This must be\n   *     a function that was added previously using addEvent. If this parameter is\n   *     not given, all event listeners of the corresponding `type` argument will\n   *     be removed.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#removeListener}\n   * @see {@link module:spotify-eventemitter#removeListeners}\n   */\n  EventEmitter.prototype.off = function(type, opt_listener) {\n    if (typeof opt_listener === 'function') {\n      return this.removeEvent(type, opt_listener);\n    }\n    // if no listener set, remove all the listeners from the event\n    this._listenerMap[type] = null;\n    return this;\n  };\n\n  /**\n   * Exporting\n   */\n  module.exports = EventEmitter;\n\n},{\"spotify-deferred\":1}],3:[function(require,module,exports){\n  'use strict';\n\n  /**\n   * Makes a class inherit from a superclass' prototype indirectly.\n   *\n   * @param {Spotify.ClassLike} Sub The class that will inherit.\n   * @param {Spotify.ClassLike} Super The class to inherit from.\n   */\n  var inherit = function(Sub, Super) {\n    var superProto = Super.prototype;\n    function Superclass() {}\n    Superclass.prototype = Sub._super = superProto;\n    Superclass.prototype.constructor = Super;\n    Sub.prototype = new Superclass();\n  };\n\n\n  /**\n   * Export public interface\n   */\n  module.exports = inherit;\n\n},{}],4:[function(require,module,exports){\n  arguments[4][1][0].apply(exports,arguments)\n},{\"dup\":1}],5:[function(require,module,exports){\n  /**\n   * @file\n   * Implements a Promise class that represents an eventually resolved value.\n   */\n  'use strict';\n\n\n  /**\n   * @type {function(number, number)}\n   * @private\n   */\n  var slice = Array.prototype.slice;\n\n  var defer = require('spotify-deferred');\n\n\n  /**\n   * A utility function for piping the values of a promise to another promise.\n   *\n   * Used internally to avoid having to use bind.\n   *\n   * @param {Spotify.Promise} promiseA The first promise.\n   * @param {Spotify.Promise} promiseB The second promise.\n   * @private\n   */\n  function pipe(promiseA, promiseB) {\n    promiseA.then(function(object) {\n      promiseB.fulfill(object);\n    }, function(error) {\n      promiseB.fail(error);\n    });\n  }\n\n\n  /**\n   * The state of the the promise.\n   *\n   * @enum {number}\n   * @private\n   */\n  var states = {\n    UNFULFILLED: 0,\n    FULFILLED: 1,\n    FAILED: 2\n  };\n\n\n  /**\n   * A promise object.\n   *\n   * @constructs Spotify.Promise\n   */\n  function Promise() {\n    this._state = states.UNFULFILLED;\n    this._value = null;\n    this._handlers = [];\n    this._deferred = false;\n  }\n\n\n  /**\n   * Defers a promise.\n   *\n   * @private\n   */\n  Promise.defer = typeof setImmediate == 'function' ?\n    // We wrap setImmediate (which is used in node) in a function because IE10\n    // exports its own non-standard setImmediate function. This IE function\n    // depends on being called from a global scope (most likely because of a\n    // binding within the native implementation).\n    function(fn) { setImmediate(fn); } :\n    defer;\n\n\n  /**\n   * Check whether the promise is unfulfilled.\n   *\n   * @return {boolean} True if the promise hasn't been fulfilled.\n   */\n  Promise.prototype.isUnfulfilled = function() {\n\n    return this._state == states.UNFULFILLED;\n  };\n\n\n  /**\n   * Check whether the promise has been fulfilled.\n   *\n   * @return {boolean} True if the promise has been fulfilled and\n   *     didn't fail.\n   */\n  Promise.prototype.isFulfilled = function() {\n    return this._state == states.FULFILLED;\n  };\n\n\n  /**\n   * Check whether the promise has failed.\n   *\n   * @return {boolean} True if the promise has failed.\n   */\n  Promise.prototype.isFailed = function() {\n    return this._state == states.FAILED;\n  };\n\n\n  /**\n   * Fulfills the promise.\n   *\n   * @param {*} value The fulfilled value of the promise.\n   */\n  Promise.prototype.fulfill = function(value) {\n    var self = this;\n    if (this._state !== states.UNFULFILLED) return;\n    this._value = value;\n    this._state = states.FULFILLED;\n    if (!this._deferred) {\n      Promise.defer(function() { self._runHandlers(); });\n      this._deferred = true;\n    }\n    return;\n  };\n\n\n  /**\n   * Fails the promise.\n   *\n   * @param {*} error The failed value of the promise.\n   */\n  Promise.prototype.fail = function(error) {\n    var self = this;\n    if (this._state !== states.UNFULFILLED) return;\n    this._value = error;\n    this._state = states.FAILED;\n    if (!this._deferred) {\n      Promise.defer(function() { self._runHandlers(); });\n      this._deferred = true;\n    }\n    return;\n  };\n\n\n  /**\n   * Adds fulfillment and failure handlers to the promise.\n   *\n   * @param {function(*)} fulfilledHandler The function to be called when a\n   *     promise is fulfilled.\n   * @param {function(*)} failedHandler The function to be called when a\n   *     promise failed.\n   * @return {Spotify.Promise} A new promise that could be used to chain handlers.\n   */\n  Promise.prototype.then = function(fulfilledHandler, failedHandler) {\n    var self = this;\n    var promise = new Promise();\n    this._handlers.push({\n      fulfilled: fulfilledHandler,\n      failed: failedHandler,\n      promise: promise\n    });\n    if (this._state !== states.UNFULFILLED && !this._deferred) {\n      Promise.defer(function() { self._runHandlers(); });\n      this._deferred = true;\n    }\n    return promise;\n  };\n\n\n  /**\n   * Passes the fulfillment or failure values of one promise to another.\n   *\n   * @param {Spotify.Promise} promise The promise to which the values will be passed.\n   */\n  Promise.prototype.pipe = function(promise) {\n    this.then(function(value) {\n      promise.fulfill(value);\n    }, function(error) {\n      promise.fail(error);\n    });\n    return;\n  };\n\n\n  /**\n   * Executes the handlers after a promise has been resolved.\n   *\n   * @private\n   */\n  Promise.prototype._runHandlers = function() {\n    this._deferred = false;\n    var value = this._value;\n    if (this._state == states.UNFULFILLED) return;\n    var fulfilled = this._state === states.FULFILLED;\n    var handlers = this._handlers.splice(0);\n    var callbackType = fulfilled ? 'fulfilled' : 'failed';\n    for (var i = 0, l = handlers.length; i < l; i++) {\n      var handler = handlers[i];\n      var callback = handler[callbackType];\n      var promise = handler.promise;\n      if (!callback || typeof callback != 'function') {\n        if (value && typeof value.then == 'function') {\n          pipe(value, promise);\n          continue;\n        } else {\n          if (fulfilled) {\n            promise.fulfill(value);\n          } else {\n            promise.fail(value);\n          }\n          continue;\n        }\n      }\n      try {\n        var returnValue = callback(value);\n      } catch (e) {\n        promise.fail(e);\n        continue;\n      }\n      if (returnValue && typeof returnValue.then == 'function') {\n        pipe(returnValue, promise);\n      } else {\n        promise.fulfill(returnValue);\n      }\n    }\n  };\n\n\n// Convenience Methods\n\n\n  /**\n   * A convenience method for adding a failedHandler to a promise\n   * without adding a fulfillmentHandler.\n   *\n   * @param {function(*)} failedHandler A function that will be called\n   *     when a promise fails.\n   * @return {Spotify.Promise} A new promise that could be used to chain\n   *     other handlers.\n   */\n  Promise.prototype.catchError = function(failedHandler) {\n    return this.then(null, failedHandler);\n  };\n\n\n  /**\n   * A convenience method that will return a promise that resolves\n   * to a named property of the fulfillment value of the current\n   * promise.\n   *\n   * @param {string} property The property to resolve.\n   * @return {Spotify.Promise} A promise that will be resolved to the value\n   *     of the current promises' named property.\n   */\n  Promise.prototype.get = function(property) {\n    var promise = new Promise();\n    this.then(function(object) {\n      if (property in object) {\n        promise.fulfill(object[property]);\n      } else {\n        promise.fail(\n          new TypeError('No property \"' + property + '\" in object.')\n        );\n      }\n    }, function(error) {\n      promise.fail(error);\n    });\n    return promise;\n  };\n\n\n  /**\n   * A convenience method that will return a promise that resolves to a set of\n   * named-properties of the fulfillment values of the promise.\n   *\n   * @param {...string} var_args A set of property names.\n   * @return {Spotify.Promise} A promise that will be fulfilled with the proper\n   *     value or a TypeError.\n   */\n  Promise.prototype.access = function(var_args) {\n    var_args = Array.isArray(var_args) ? var_args : slice.call(arguments);\n    var promise = this;\n    for (var i = 0, l = var_args.length; i < l; i++) {\n      promise = promise.get(var_args[i]);\n    }\n    return promise;\n  };\n\n\n  /**\n   * A convenience method that will execute a method of the current\n   * promise's fulfillment value.\n   *\n   * @param {string} method The method to execute.\n   * @param {...*} var_args The arguments to apply for the method.\n   * @return {Spotify.Promise} A promise that will be resolved to the return\n   *     value of the current promises' method after execution.\n   */\n  Promise.prototype.call = function(method, var_args) {\n    var args = slice.call(arguments, 1);\n    var promise = new Promise();\n    this.then(function(object) {\n      try { promise.fulfill(object[method].apply(object, args)); }\n      catch (e) { promise.fail(e); }\n    }, function(error) {\n      promise.fail(error);\n    });\n    return promise;\n  };\n\n\n  /**\n   * Works similar to the then() method, but spread an array fulfillment\n   * value as parameters to the fulfilledHandler.\n   *\n   * @param {function(...*)} fulfilledHandler The function to be called when a\n   *     promise is fulfilled.\n   * @param {function(*)} failedHandler The function to be called when a\n   *     promise failed.\n   * @return {Spotify.Promise} A new promise that could be used to chain handlers.\n   */\n  Promise.prototype.thenSpread = function(fulfilledHandler, failedHandler) {\n    return this.then(function(value) {\n      return Array.isArray(value) ? fulfilledHandler.apply(this, value) : fulfilledHandler.call(this, value);\n    }, failedHandler);\n  };\n\n\n  /**\n   * Creates a joined promise, which will be fulfilled with the values\n   * of all the promises passed to the function.\n   *\n   * The returned promise is failed immediately if one of the promises fails.\n   *\n   * @param {Array.<Spotify.Promise>|...Spotify.Promise} promises\n   *     The promises to join.\n   * @return {Spotify.Promise} The promise that will be fulfilled\n   *     with the values of all promises passed.\n   */\n  Promise.join = function(promises) {\n    promises = Array.isArray(promises) ? promises : slice.call(arguments);\n    var promise = new Promise();\n    var length = promises.length;\n    var result = [];\n    var failed = false;\n    var aggregator = function(index, obj) {\n      if (failed) return;\n      result[index] = obj;\n      length--;\n      if (!length) promise.fulfill(result);\n    };\n    var failure = function(error) {\n      if (failed) return;\n      failed = true;\n      promise.fail(error);\n    };\n    for (var i = 0, l = length; i < l; i++) {\n      var p = promises[i];\n      if (!p || !p.then) {\n        aggregator(i, p);\n      } else {\n        p.then(aggregator.bind(null, i), failure);\n      }\n    }\n    return promise;\n  };\n\n\n  /**\n   * Creates a grouping promise, which can be used to fullfill all the\n   * promises passed.\n   *\n   * @param {Array.<Spotify.Promise>|...Spotify.Promise} promises\n   *     The promises to group.\n   * @return {Spotify.Promise} A promise that can be used to fulfill\n   *     all the promises passed.\n   */\n  Promise.group = function(promises) {\n    promises = Array.isArray(promises) ? promises : slice.call(arguments);\n    var promise = new Promise();\n    for (var i = 0, l = promises.length; i < l; i++) {\n      promise.pipe(promises[i]);\n    }\n    return promise;\n  };\n\n\n  /**\n   * Export public interface\n   */\n  module.exports = Promise;\n\n},{\"spotify-deferred\":4}],6:[function(require,module,exports){\n  'use strict';\n\n  var inherit = require('spotify-inheritance/inherit');\n  var EventEmitter = require('spotify-eventemitter');\n  var Promise = require('spotify-promise');\n\n  /**\n   * The Spotify Remote Control (WebHelper) JS wrapper constructor.\n   *\n   * @param {Object} settings   The settings object\n   * @params {?Object} win   The mocked window object. Only used for testing purposes.\n   */\n  function RemoteControl(settings, win) {\n    if (!this instanceof RemoteControl) {\n      return new RemoteControl(options);\n    }\n    EventEmitter.call(this);\n\n    settings = settings || {};\n\n    this._win = win || window;\n    this._protocol = settings.protocol || this._win.location.protocol;\n\n    this._csrf = '';\n    if (settings.debug) {\n      this._startPort = this._endPort = settings.port;\n    } else {\n      this._startPort = 'https:' === this._protocol ? 4370 : 4380;\n      this._endPort = 'https:' === this._protocol ? 4379 : 4389;\n    }\n    this._currentPort = this._startPort;\n    this._runningPort = 0;\n    this._subdomain = '';\n    this._clientOpen = false;\n    this._clientRunning = false;\n    this._connected = false;\n    this._backoffIndex = 0;\n    this.state = null;\n    if (settings.hasOwnProperty('autoOpen')) {\n      this._autoOpen = settings.autoOpen;\n    } else {\n      this._autoOpen = false;\n    }\n    this._retryConnect = settings.retryConnect || false;\n    this._reconnectOnLogout = settings.reconnectOnLogout || false;\n    this._reopenOnReconnect = settings.reopenOnReconnect || false;\n    this._localhost = settings.debug || settings.localhost || false;\n    this._pollClient = settings.pollClient || false;\n    this._pollBackoff = settings.pollBackoff || [1, 1, 1, 1, 3, 3, 5];\n    this._longPollingTime = settings.longPollingTime || 60000;\n    this._token = settings.token || '';\n    this._referrer = settings.referrer || this._win.location.href;\n  }\n  inherit(RemoteControl, EventEmitter);\n  module.exports = RemoteControl;\n\n  /**\n   * @var {Object}   Events that are fired by the remoteControl.\n   */\n  var Event = {\n    'STATUS_CHANGE': 'STATUS_CHANGE',\n    'CONNECTION_ESTABLISHED': 'CONNECTION_ESTABLISHED',\n    'CONNECTION_FAILED': 'CONNECTION_FAILED'\n  };\n  RemoteControl.Event = Event;\n\n  /**\n   * @var {Object}   Error types that can be returned in an event\n   */\n  var Error = {\n    'INVALID_OAUTH_TOKEN': '4102',\n    'EXPIRED_OAUTH_TOKEN': '4103',\n    'INVALID_CSRF_TOKEN': '4107',\n    'OAUTH_TOKEN_INVALID_FOR_USER': '4108',\n    'NO_USER_LOGGED_IN': '4110',\n    'COULD_NOT_DETECT_PORT': '6000',\n    'COULD_NOT_OPEN_CLIENT': '6010',\n    'COULD_NOT_FETCH_CSRF_TOKEN': '6020',\n    'COULD_NOT_FETCH_STATUS': '6030',\n    'COULD_NOT_PLAY_TRACK': '6040',\n    'NO_TRACK_LOADED': '6050',\n    'CORS_REQUESTS_DISABLED': '6060',\n    'REQUEST_TIMED_OUT': '6061'\n  };\n  RemoteControl.Error = Error;\n\n  /**\n   * Check if the submitted uri is the track currently playing\n   *\n   * @param {String} uri   The trackUri to check for\n   * @return {bool}   true if the specified track uri is the\n   *                  one currently playing, else false.\n   */\n  RemoteControl.prototype.isCurrent = function(uri) {\n    var state = this.state;\n    return state !== null && state.track && state.track.track_resource &&\n      state.track.track_resource.uri == uri;\n  };\n\n  /**\n   * Check if remote control API is enabled\n   * This will return false until the port has been detected.\n   *\n   * @return {bool}   true if remote control enabled, else false.\n   */\n  RemoteControl.prototype.enabled = function() {\n    return this._runningPort > 0;\n  }\n\n  /**\n   * Detect what port the webHelper is running on.\n   *\n   * In case this._pollClient == true, it will continue to\n   * poll for the port until it finds it according to the\n   * poll backoff schema specified in this._pollBackoff\n   *\n   * @param {?Promise} promise   The promise to fulfill if found.\n   *                             Only used by the funtion itself.\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._detectPort = function(promise) {\n\n    promise = promise || new Promise();\n    if (0 < this._runningPort) {\n      promise.fulfill(this._runningPort);\n    } else {\n      var self = this;\n      var url = this._buildUrl('service/version.json', {service: 'remote'});\n\n      self._request(url, function(err, result) {\n        if (err) {\n          if (self._currentPort < self._endPort) {\n            self._currentPort++;\n            self._detectPort(promise);\n          } else if (self._pollClient) {\n            self._currentPort = self._startPort;\n            setTimeout(function() {\n              self._detectPort(promise);\n            }, self._nextPollInterval() * 1000);\n          } else {\n            promise.fail({type: Error.COULD_NOT_DETECT_PORT, message: 'Could not detect any port'});\n          }\n        } else {\n          self._resetBackoffCounter();\n          self._runningPort = self._currentPort;\n          self._clientRunning = true;\n          self._clientOpen = result.running !== false;\n          promise.fulfill(self._currentPort);\n        }\n      });\n    }\n\n    return promise;\n  };\n\n  /**\n   * Open the client if it is not already running\n   *\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._openClient = function() {\n    var self = this;\n\n    var promise = new Promise();\n    if (self._clientOpen) {\n      promise.fulfill();\n    } else if (self._autoOpen){\n      var url = self._buildUrl('remote/open.json');\n\n      self._request(url, function(err, result) {\n        if (err) {\n          promise.fail({type: Error.COULD_NOT_OPEN_CLIENT, message: 'Could not open client'});\n        } else {\n          if (!result.running) {\n            promise.fail({type: Error.COULD_NOT_OPEN_CLIENT, message: 'Could not open client'});\n          } else {\n            self._clientOpen = true;\n            promise.fulfill();\n          }\n        }\n      }, 10000);\n    } else {\n      promise.fulfill();\n    }\n\n    return promise;\n\n  };\n\n  /**\n   * Fetch the csrf token to use with the web helper.\n   *\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._csrfToken = function() {\n    var self = this;\n\n    var promise = new Promise();\n\n    if ('' !== self._csrf) {\n      promise.fulfill(self._csrf);\n    } else {\n      var url = self._buildUrl('simplecsrf/token.json');\n\n      self._request(url, function(err, result) {\n        if (err) {\n          promise.fail({type: Error.COULD_NOT_FETCH_CSRF_TOKEN, message: 'Could not fetch csrf token'});\n        } else {\n          if (!result.token) {\n            promise.fail({type: Error.COULD_NOT_FETCH_CSRF_TOKEN, message: 'Could not fetch csrf token'});\n          } else {\n            self._csrf = result.token;\n            promise.fulfill(result.token);\n          }\n        }\n      });\n    }\n\n    return promise;\n  };\n\n  /**\n   * Fetch the current status from the client\n   *\n   * If this function is used for longPolling the status, it will not\n   * return until the status changes.\n   *\n   * @param {bool} longPolling   Pass true to not return until status changes\n   * @param {int} timeout   The timeout to use for the request\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._status = function(longPolling, callback, timeout) {\n    var self = this;\n\n    var params = {\n      'csrf': self._csrf,\n      'oauth': self._token\n    };\n    timeout = timeout || 500;\n    if (longPolling) {\n      params['returnon'] = 'login,logout,play,pause,error,ap';\n      params['returnafter'] = timeout / 1000;\n    }\n\n    var url = self._buildUrl('remote/status.json', params);\n\n    this._request(url, function(err, result) {\n      if (err) {\n        var type = err.type || Error.COULD_NOT_FETCH_STATUS;\n        callback({type: type, message: 'Could not fetch status'});\n      } else {\n        if (result.error) {\n          if (result.running === false) {\n            self._clientOpen = false;\n          }\n          callback(result.error);\n        } else {\n          callback(null, result);\n        }\n      }\n    }, timeout + 1000); // To let the long polling function return\n  };\n\n  /**\n   * The event loop runner that opens a long polling connection to\n   * listen for status changes. The event loop will be restarted every\n   * time it gets a response or times out.\n   *\n   * This function is the one dispatching events that the user of this\n   * class can listen for.\n   *\n   * @private\n   */\n  RemoteControl.prototype._statusChange = function() {\n    var self = this;\n    this._status(true, function(err, status) {\n      if (err) {\n        err.code = err.code || err.type;\n        switch(err.code) {\n          case Error.NO_USER_LOGGED_IN:\n            // Login user if possible\n            self._connected = false;\n            self._connection = null;\n            if (self._reconnectOnLogout) {\n              self._reconnect();\n            }\n            self.emit(Event.CONNECTION_FAILED, err);\n            break;\n          case Error.INVALID_OAUTH_TOKEN:\n          case Error.EXPIRED_OAUTH_TOKEN:\n          case Error.OAUTH_TOKEN_INVALID_FOR_USER:\n            self._token = '';\n            self._connected = false;\n            self._connection = null;\n            self.emit(Event.CONNECTION_FAILED, err);\n            break;\n          case Error.INVALID_CSRF_TOKEN:\n            self._csrf = '';\n            self._csrfToken()\n              .then(function() {\n                self._statusChange();\n                return;\n              });\n            break;\n          default:\n            self._connected = false;\n            self._connection = null;\n            self.emit(Event.CONNECTION_FAILED, err);\n            break;\n        }\n      } else {\n        self._statusChange();\n        self.state = status;\n        self.emit(Event.STATUS_CHANGE, status);\n      }\n    }, self._longPollingTime);\n  };\n\n  /**\n   * Connect to the web helper by fetching status\n   * and starting the event loop handler\n   *\n   * @return {Promise}   The current status of the client\n   * @private\n   */\n  RemoteControl.prototype._connect = function() {\n    var self = this;\n    var promise = new Promise();\n    if (self._connected) {\n      promise.fulfill(self.state);\n    } else {\n      self._status(false, function(err, status) {\n        if (err) {\n          switch (err.type) {\n            case Error.NO_USER_LOGGED_IN:\n              if (self._retryConnect) {\n                setTimeout(function() {\n                  self._reconnect()\n                    .then(function(status) {\n                      promise.fulfill(status);\n                    });\n                }, self._nextPollInterval() * 1000);\n              } else {\n                promise.fail(err);\n              }\n              break;\n            default:\n              promise.fail(err);\n              break;\n          }\n        } else {\n          self._resetBackoffCounter();\n          self._connected = true;\n          self.state = status;\n          self._statusChange();\n          promise.fulfill(status);\n        }\n      });\n    }\n    return promise;\n  }\n\n  /**\n   * Connect to the web helper to be able to control the client\n   *\n   * This function starts the event loop and returns a promise\n   * with the current status.\n   *\n   * @return {Promise}   A promise with the current status\n   */\n  RemoteControl.prototype.connect = function() {\n    var self = this;\n    if (!this._connection) {\n      this._connection = this._detectPort()\n        .then(function() {\n          return self._openClient();\n        })\n        .then(function() {\n          return self._csrfToken();\n        })\n        .then(function() {\n          return self._connect();\n        });\n    }\n    return this._connection\n      .then(function(status) {\n        return self.state || status;\n      });\n  };\n\n  /**\n   * Start a reconnection loop to detect when client has been started\n   *\n   * @return {Promise}   A promise with the current status\n   */\n  RemoteControl.prototype._reconnect = function() {\n    var self = this;\n    return this._detectPort()\n      .then(function() {\n        if (self._reopenOnReconnect) {\n          return self._openClient()\n        } else {\n          return self;\n        }\n      })\n      .then(function() {\n        return self._csrfToken();\n      })\n      .then(function() {\n        return self._connect();\n      });\n  }\n\n  /**\n   * Set the oauth token to use when connecting.\n   *\n   * This can be used when the oauth token needs to be update,\n   * for example when it has expired.\n   *\n   * @param {String} token   The new oauth token.\n   */\n  RemoteControl.prototype.setToken = function(token) {\n    this._token = token;\n  };\n\n  /**\n   * Play a specified context or track\n   *\n   * If the trackUri is omitted, the first playable track of the\n   * context is being played instead.\n   *\n   * @param {String} context   The context URI\n   * @param {?String} trackUri   The track URI to play.\n   * @return {Promise}   A promise with the updated status\n   */\n  RemoteControl.prototype.play = function(context, trackUri) {\n\n    var self = this;\n    var playPromise = (this._playPromise && this._connection) ? this._playPromise : this.connect();\n    return this._playPromise = playPromise\n      .then(function(status) {\n        var params = {\n          'csrf': self._csrf,\n          'oauth': self._token,\n          'context': context\n        };\n        params['uri'] = trackUri || context;\n\n        var promise = new Promise();\n\n        var url = self._buildUrl('remote/play.json', params);\n        self._request(url, function(err, result) {\n          if (err) {\n            var type = err.type || Error.COULD_NOT_PLAY_TRACK;\n            //throw {type: type, message: 'Could not play track'};\n            promise.fulfill();\n          } else {\n            if (result.error) {\n              //throw result.error;\n              promise.fulfill();\n            } else {\n              self.state = result;\n              self.emit(Event.STATUS_CHANGE, result);\n              promise.fulfill(result);\n            }\n          }\n        });\n\n        return promise;\n      },\n      function(error) {\n        self._playPromise = null;\n        throw error;\n      });\n  };\n\n  /**\n   * Pause or resume any current loaded track depending\n   * on what is specified.\n   *\n   * @param {bool} pause   Set to true to pause the track\n   *                       and to false to resume it.\n   * @return {Promise}   A promise with the updated state after operation.\n   * @private\n   */\n  RemoteControl.prototype._pause = function(pause) {\n    var promise = new Promise();\n\n    var params = {\n      'csrf': this._csrf,\n      'oauth': this._token,\n      'pause': pause === true ? 'true' : 'false'\n    };\n\n    var url = this._buildUrl('remote/pause.json', params);\n    this._request(url, function(err, result) {\n      if (err) {\n        var type = err.type || Error.COULD_NOT_TOGGLE_PLAYBACK;\n        promise.fail({type: type, message: 'Could not toggle playback'});\n      } else {\n        if (result.error) {\n          promise.fail(result.error);\n        } else {\n          promise.fulfill(result);\n        }\n      }\n    });\n\n    return promise;\n  };\n\n  /**\n   * Pauses any loaded and playing track\n   *\n   * @return {Promise}   A promise with the paused status\n   */\n  RemoteControl.prototype.pause = function() {\n    var self = this;\n    return this.connect()\n      .then(function(status) {\n        var promise = new Promise();\n        if (!status.track || !status.track.track_resource || !status.track.track_resource.uri) {\n          promise.fail({\n            type: Error.NO_TRACK_LOADED,\n            message: 'Could not pause non existing track'\n          });\n        } else {\n          self._pause(true)\n            .then(function(pauseStatus) {\n              promise.fulfill(pauseStatus);\n            });\n        }\n        return promise;\n      });\n  };\n\n  /**\n   * Toggle play pause for a loaded track\n   *\n   * @return {Promise}   A promise with the status after toggle\n   */\n  RemoteControl.prototype.toggle = function() {\n    var self = this;\n    return this.connect()\n      .then(function(status) {\n        var promise = new Promise();\n        if (!status.track || !status.track.track_resource || !status.track.track_resource.uri) {\n          promise.fail({\n            type: Error.NO_TRACK_LOADED,\n            message: 'Could not toggle playback for non existing track'\n          });\n        } else {\n          self._pause(status.playing)\n            .then(function(pauseStatus) {\n              promise.fulfill(pauseStatus);\n            });\n        }\n        return promise;\n      });\n  };\n\n  /**\n   * Get a web token if there is a logged in user in the desktop client\n   *\n   * @return {Promise}   A promise with the web token\n   */\n  RemoteControl.prototype.getWebToken = function() {\n    var self = this;\n    return this.connect()\n      .then(function(status) {\n        var params = {\n          'csrf': self._csrf,\n          'oauth': self._token,\n        };\n\n        var promise = new Promise();\n\n        var url = self._buildUrl('remote/webtoken.json', params);\n        self._request(url, function(err, result) {\n          if (err) {\n            promise.fail({\n              type: Error.COULD_NOT_BROWSE_TO_CONTEXT,\n              message: 'Could not get web token'\n            });\n          } else {\n            if (result.error) {\n              promise.fail(result.error);\n            } else {\n              promise.fulfill(result);\n            }\n          }\n        });\n\n        return promise;\n      },\n      function(error) {\n        throw error;\n      });\n  };\n\n  /**\n   * Generate the base connection url\n   *\n   * @return {String}   The base connection url\n   * @private\n   */\n  RemoteControl.prototype._baseUrl = function() {\n    if (this._localhost) {\n      return '//localhost';\n    }\n\n    var min = 97;\n    var max = 122;\n    if ('' === this._subdomain) {\n      for (var i=0; i < 10; ++i) {\n        this._subdomain += String.fromCharCode(Math.floor(Math.random() * (max - min + 1)) + min);\n      }\n    }\n    return '//' + this._subdomain + '.spotilocal.com';\n  };\n\n  /**\n   * Make an XHR request\n   *\n   * @param {String} url   The requested url\n   * @param {?int} timeout   The timeout for this request. Defaults to 5000 ms.\n   * @return {Promise}   A promise with the response body JSON decoded\n   * @private\n   */\n  RemoteControl.prototype._request = function(url, callback, timeout) {\n\n    var self = this;\n\n    function getXdr() {\n      if ('undefined' !== typeof self._win.XDomainRequest) {\n        return new self._win.XDomainRequest();\n      } else if ('undefined' !== typeof self._win.XMLHttpRequest) {\n        return new self._win.XMLHttpRequest();\n      } else {\n        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n        try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n        try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n      }\n      return null;\n    };\n\n    var xdr = getXdr();\n    if (xdr) {\n      xdr.onload = function() {\n        var data = xdr.responseText;\n        data = JSON.parse(data);\n        callback(null, data);\n      };\n\n      xdr.onerror = function() {\n        callback({type: xdr.status, message: 'Request error'});\n      };\n\n      xdr.ontimeout = function() {\n        callback({type: Error.REQUEST_TIMED_OUT, message: 'Request timed out'});\n      };\n\n      xdr.onprogress = function() {};\n\n      xdr.open('GET', url);\n      xdr.timeout = timeout ? timeout : 5000;\n      xdr.send();\n    } else {\n      callback({\n        type: Error.CORS_REQUESTS_DISABLED,\n        message: 'CORS Requests are not enabled'\n      });\n    }\n  };\n\n  /**\n   * Builds a url for use with the remote control\n   *\n   * @param {String} endpoint   The API endpoint\n   * @param {Object} params   The query parameters to be added\n   * @return {String}   The full URL\n   */\n  RemoteControl.prototype._buildUrl = function(endpoint, params) {\n    params = params || {};\n    params.cors = '';\n    params.ref = params.ref || this._referrer;\n    var queryParams = this._buildQuery(params);\n    return this._baseUrl() + ':' + this._currentPort + '/' + endpoint + '?' + queryParams;\n  };\n\n  /**\n   * Build the query parameter string\n   * This function url encodes all keys and all values.\n   *\n   * @param {Object} params   The query params to join\n   * @return {String}   The generated query string\n   */\n  RemoteControl.prototype._buildQuery = function(params) {\n    var query = [];\n    for (var key in params) {\n      query.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n    }\n    return query.join(\"&\");\n  };\n\n  /**\n   * Get the next poll interval timeout based on the backoff strategy\n   *\n   * @return {int}   The next poll interval to use\n   */\n  RemoteControl.prototype._nextPollInterval = function() {\n    var interval = this._pollBackoff[this._backoffIndex];\n    if (this._pollBackoff[this._backoffIndex + 1]) {\n      this._backoffIndex++;\n    }\n    return interval;\n  };\n\n  /**\n   * Reset the index for fetching backoff interval\n   */\n  RemoteControl.prototype._resetBackoffCounter = function() {\n    this._backoffIndex = 0;\n  };\n\n},{\"spotify-eventemitter\":2,\"spotify-inheritance/inherit\":3,\"spotify-promise\":5}],7:[function(require,module,exports){\n  spweb.remotecontrol = require('spotify-remote');\n\n},{\"spotify-remote\":6}]},{},[7]);\n"},314:function(n,e,t){"use strict";t(0)(t(315))},315:function(n,e){n.exports="jQuery(function ($, FastClick, spweb) {\n\n  'use strict';\n\n  var body = $('body');\n\n  /**\n   * FastClick is a 3rd party lib that removes\n   * the 300ms click delay on ios. It will only attach listeners\n   * when needed. There's no overhead otherwise, aside from file\n   * being loaded everywhere. https://github.com/ftlabs/fastclick\n   */\n  if (typeof FastClick === 'function') {\n    spweb.fastClick = FastClick.attach(document.body);\n  }\n\n  spweb.securityMonitor.init();\n  spweb.navbar.init(); // must run before spweb.messageBars.init()\n  spweb.messageBars.init();\n  spweb.analytics.init();\n  spweb.tracking.init();\n\n  if (window.navigator.appVersion.indexOf(\"MSIE 8\") > -1) {\n    $('html').addClass('ie8');\n  }\n  /**\n   * Direct logged out user to signup/login page on click of anchor elements\n   * with js-goto-signup or js-goto-login hooks. The anchor's href value will be set\n   * as the encoded value of the forward_url query parameter.\n   *\n   * Example:\n   *\n   *  A user clicks an anchor that is marked up as:\n   *    <a href=\"/us/download/\" class=\"js-goto-signup\">Download Spotify</a>\n   *\n   *  will be redirected to:\n   *    http://www.spotify.com/signup/?forward_url=%2Fus%2Fdownload%2Fmac%2F\n   *\n   * Also, ensure the user is in a launched market and not on a mobile device\n   */\n  if (spweb.user.getMarket() !== 'int' && !spweb.detect.detect().mobile && $('.reboot.is-loggedout').length > 0) {\n    $('.js-goto-signup').on('click.register', spweb.utils.goToSignup);\n  }\n\n  /**\n   * Trigger autologin if available and not logged in\n   * Also, ensure the user is in a launched market\n   */\n  if (spweb.user.getMarket() !== 'int' && $('.reboot.is-loggedout').length > 0) {\n    $('.js-goto-auto-login').on('click.login', spweb.utils.goToAutoLogin);\n\n    if ($('.js-goto-auto-login').length > 0) {\n      spweb.utils.autoLogin();\n    }\n  }\n\n}(jQuery, FastClick, spweb));\n"},468:function(n,e,t){t(219),t(213),t(290),t(221),t(292),t(223),t(294),t(296),t(298),t(174),t(300),t(302),t(304),t(225),t(306),t(308),t(310),t(312),n.exports=t(314)}});
//# sourceMappingURL=spweb-site.min.58cd95300b17959cef73.js.map